<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel æ•°æ®åŒ¹é…å·¥å…· - A.O.å²å¯†æ–¯ä¸šåŠ¡å·¥å…·å¹³å°</title>
    
    <!-- ç»Ÿä¸€æ ·å¼ -->
    <link rel="stylesheet" href="../../common-styles.css">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        /* å·¥å…·ç‰¹å®šæ ·å¼ä¿ç•™ */

        .content {
            padding: 30px;
        }

        .step {
            margin-bottom: 30px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 12px;
            border-left: 4px solid #667eea;
        }

        .step-title {
            font-size: 20px;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .step-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            background: #667eea;
            color: white;
            border-radius: 50%;
            margin-right: 12px;
            font-size: 16px;
        }

        .file-upload-area {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .upload-box {
            border: 2px dashed #cbd5e0;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s;
            background: white;
        }

        .upload-box:hover {
            border-color: #667eea;
            background: #f7fafc;
        }

        .upload-box.has-file {
            border-color: #48bb78;
            background: #f0fff4;
        }

        .upload-box.optional {
            border-style: solid;
            border-color: #e2e8f0;
        }

        .upload-box.optional:hover {
            border-color: #a0aec0;
        }

        .upload-box.optional.has-file {
            border-color: #48bb78;
        }

        .upload-box label {
            display: block;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .optional-tag {
            display: inline-block;
            font-size: 11px;
            padding: 2px 6px;
            background: #edf2f7;
            color: #718096;
            border-radius: 3px;
            margin-left: 5px;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            display: inline-block;
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 13px;
        }

        .upload-btn:hover {
            background: #5a67d8;
            transform: translateY(-2px);
        }

        .file-info {
            margin-top: 8px;
            color: #48bb78;
            font-size: 12px;
            display: none;
        }

        .sheet-selector {
            margin-top: 8px;
            display: none;
        }

        .sheet-selector select {
            width: 100%;
            padding: 6px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            font-size: 13px;
            background: white;
        }

        .mapping-section {
            margin-bottom: 25px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .mapping-section-title {
            font-size: 16px;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e2e8f0;
        }

        .mapping-grid {
            display: grid;
            gap: 10px;
        }

        .mapping-row {
            display: grid;
            grid-template-columns: 220px 1fr 100px;
            gap: 12px;
            align-items: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }

        .mapping-label {
            font-weight: 500;
            color: #2d3748;
            font-size: 14px;
        }

        .mapping-row select {
            padding: 6px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            font-size: 13px;
            background: white;
        }

        .mapping-source {
            font-size: 11px;
            color: #718096;
            padding: 4px 8px;
            background: #edf2f7;
            border-radius: 4px;
            text-align: center;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: #48bb78;
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #38a169;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .result-area {
            margin-top: 20px;
            display: none;
        }

        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            padding: 18px;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .stat-label {
            font-size: 13px;
            color: #718096;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #2d3748;
        }

        .table-container {
            overflow-x: auto;
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
            font-size: 13px;
            white-space: nowrap;
        }

        th {
            background: #f7fafc;
            font-weight: 600;
            color: #2d3748;
            position: sticky;
            top: 0;
        }

        tr:hover {
            background: #f7fafc;
        }

        .alert {
            padding: 12px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .alert-info {
            background: #bee3f8;
            color: #2c5282;
            border-left: 4px solid #3182ce;
        }

        .alert-warning {
            background: #feebc8;
            color: #7c2d12;
            border-left: 4px solid #ed8936;
        }

        .alert-danger {
            background: #fed7d7;
            color: #742a2a;
            border-left: 4px solid #f56565;
        }

        .diagnostics-section {
            margin-top: 20px;
            padding: 15px;
            background: #f7fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .diagnostics-title {
            font-size: 16px;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 10px;
        }

        .diagnostic-item {
            padding: 8px;
            margin-bottom: 5px;
            background: white;
            border-radius: 4px;
            font-size: 13px;
            border-left: 3px solid #ed8936;
        }

        .btn-warning {
            background: #ed8936;
            color: white;
        }

        .btn-warning:hover:not(:disabled) {
            background: #dd6b20;
            transform: translateY(-2px);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #fff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="tool-container">
        <div class="tool-header" style="position: relative;">
            <a href="../../index.html" class="back-nav">â† è¿”å›é¦–é¡µ</a>
            <h1>ğŸ“Š Excel æ•°æ®åŒ¹é…å·¥å…·</h1>
            <p class="tool-subtitle">æ™ºèƒ½åŒ¹é…é”€å”®è®¢å•ã€æ”¶æ¬¾ã€å¸¦å•è´¹åŠæ”¿ç­–æ•°æ®</p>
            <div class="tool-badge">
                <span class="badge-dot"></span>
                <span>03-1 æ”¿ç­–åŒ¹é…å·¥å…·</span>
            </div>
        </div>

        <div class="tool-content">
            <!-- æ­¥éª¤1: ä¸Šä¼ æ–‡ä»¶ -->
            <div class="step">
                <div class="step-title">
                    <span class="step-number">1</span>
                    ä¸Šä¼ Excelæ–‡ä»¶
                </div>
                <div class="alert alert-info">
                    <strong>å¿…éœ€ï¼š</strong>é”€å”®è®¢å•è¡¨ï¼ˆå«ç´¯è®¡æ”¶æ¬¾é‡‘é¢å­—æ®µï¼‰ã€‚<br>
                    <strong>å¯é€‰ï¼š</strong>æ”¶æ¬¾å•ï¼ˆå¦‚è®¢å•å†…æ— æ”¶æ¬¾æ•°æ®ï¼‰ã€å¸¦å•è´¹ã€æ”¿ç­–è¡¨ã€‚<br>
                    <strong>è¯´æ˜ï¼š</strong>æ”¿ç­–è¡¨ä¼šè‡ªåŠ¨åŠ è½½æ‰€æœ‰å­è¡¨ï¼›å·¥å…·ä¼šè‡ªåŠ¨è·³è¿‡Excelå‰é¢çš„ç©ºç™½è¡Œã€‚
                </div>
                <div class="file-upload-area">
                    <div class="upload-box" id="salesOrderBox">
                        <label>é”€å”®è®¢å•è¡¨ <span style="color:#e53e3e;">*</span></label>
                        <input type="file" id="salesOrderFile" class="file-input" accept=".xlsx,.xls" />
                        <span class="upload-btn" onclick="document.getElementById('salesOrderFile').click()">
                            é€‰æ‹©æ–‡ä»¶
                        </span>
                        <div class="file-info" id="salesOrderInfo"></div>
                        <div class="sheet-selector" id="salesOrderSheetSelector">
                            <select id="salesOrderSheet"></select>
                        </div>
                    </div>

                    <div class="upload-box optional" id="paymentBox">
                        <label>æ”¶æ¬¾å•è¡¨ <span class="optional-tag">å¯é€‰</span></label>
                        <input type="file" id="paymentFile" class="file-input" accept=".xlsx,.xls" />
                        <span class="upload-btn" onclick="document.getElementById('paymentFile').click()">
                            é€‰æ‹©æ–‡ä»¶
                        </span>
                        <div class="file-info" id="paymentInfo"></div>
                        <div class="sheet-selector" id="paymentSheetSelector">
                            <select id="paymentSheet"></select>
                        </div>
                    </div>

                    <div class="upload-box optional" id="commissionBox">
                        <label>å¸¦å•è´¹è¡¨ <span class="optional-tag">å¯é€‰</span></label>
                        <input type="file" id="commissionFile" class="file-input" accept=".xlsx,.xls" />
                        <span class="upload-btn" onclick="document.getElementById('commissionFile').click()">
                            é€‰æ‹©æ–‡ä»¶
                        </span>
                        <div class="file-info" id="commissionInfo"></div>
                        <div class="sheet-selector" id="commissionSheetSelector">
                            <select id="commissionSheet"></select>
                        </div>
                    </div>

                    <div class="upload-box optional" id="policyBox">
                        <label>æ”¿ç­–è¡¨ <span class="optional-tag">å¯é€‰</span></label>
                        <input type="file" id="policyFile" class="file-input" accept=".xlsx,.xls" />
                        <span class="upload-btn" onclick="document.getElementById('policyFile').click()">
                            é€‰æ‹©æ–‡ä»¶
                        </span>
                        <div class="file-info" id="policyInfo"></div>
                        <div style="margin-top: 8px; font-size: 11px; color: #718096;">
                            å°†è‡ªåŠ¨åŠ è½½æ‰€æœ‰å­è¡¨
                        </div>
                    </div>
                </div>
            </div>

            <!-- æ­¥éª¤2: é…ç½®å­—æ®µæ˜ å°„ -->
            <div class="step">
                <div class="step-title">
                    <span class="step-number">2</span>
                    é…ç½®å­—æ®µæ˜ å°„
                </div>
                <div class="alert alert-info">
                    è¯·å°†Excelè¡¨æ ¼ä¸­çš„åˆ—åæ˜ å°„åˆ°å¯¹åº”çš„å­—æ®µã€‚ç³»ç»Ÿå·²æ™ºèƒ½è¯†åˆ«å¹¶é¢„é€‰ï¼Œå¯æ‰‹åŠ¨è°ƒæ•´ã€‚
                </div>
                
                <div id="mappingContainer"></div>
            </div>

            <!-- æ­¥éª¤3: æ‰§è¡ŒåŒ¹é… -->
            <div class="step">
                <div class="step-title">
                    <span class="step-number">3</span>
                    æ‰§è¡ŒåŒ¹é…
                </div>
                <button class="btn btn-primary" id="matchBtn" onclick="performMatch()" disabled>
                    å¼€å§‹åŒ¹é…
                </button>
            </div>

            <!-- ç»“æœå±•ç¤º -->
            <div class="result-area" id="resultArea">
                <div class="step">
                    <div class="step-title">
                        <span class="step-number">âœ“</span>
                        åŒ¹é…ç»“æœ
                    </div>
                    
                    <div class="result-stats" id="resultStats"></div>

                    <div class="table-container" style="max-height: 600px; overflow-y: auto;">
                        <table id="resultTable">
                            <thead>
                                <tr id="resultTableHeader"></tr>
                            </thead>
                            <tbody id="resultTableBody"></tbody>
                        </table>
                    </div>

                    <div style="margin-top: 20px;">
                        <button class="btn btn-success" onclick="exportResult()">
                            å¯¼å‡ºç»“æœ
                        </button>
                        <button class="btn btn-warning" onclick="exportUnmatchedData()">
                            å¯¼å‡ºè¯Šæ–­æ•°æ®
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€æ•°æ®å­˜å‚¨
        const dataStore = {
            salesOrder: { data: null, headers: [], workbook: null },
            payment: { data: null, headers: [], workbook: null },
            commission: { data: null, headers: [], workbook: null },
            policy: { 
                workbook: null,
                sheets: {
                    specialMachine: { data: null, headers: [] },
                    chanet: { data: null, headers: [] },
                    boiler: { data: null, headers: [] },
                    activity: [], // æ”¹ä¸ºæ•°ç»„ï¼Œæ”¯æŒå¤šä¸ªæ—¶é—´æ®µçš„æ´»åŠ¨å­è¡¨
                    priceTable: { data: null, headers: [] }
                }
            }
        };

        let matchResult = [];
        let matchDiagnostics = {
            similarOrderNumbers: [],
            unmatchedOrders: [],
            unmatchedPayments: [],
            paymentMatches: []
        };

        // é—¨åº—ç™½åå•ï¼šåªä¿ç•™è¿™äº›é—¨åº—çš„æ•°æ®
        const storeWhitelist = [
            'ï¼ˆæ–°ï¼‰æ»¨æ±Ÿç¬¬å…­ç©ºé—´ä¸“å–åº—',
            'æ»¨æ±Ÿå…­ç©º8090åº—',
            'æ­å·æ’å¤§å»ºæè¶…çº§æ——èˆ°åº—',
            'æ­å·çº¢æ˜Ÿç¾å‡¯é¾™ä¸€å·åº—',
            'æ­å·ä¸´å¹³æ±Ÿå—å®¶å±…ä¸“å–åº—',
            'é‡‘åé¾™è…¾å»ºæå¸‚åœºä¸“å–åº—',
            'è§å±±ç¬¬å…­ç©ºé—´ä¸“å–åº—'
        ];

        // é—¨åº—è¿‡æ»¤ç»Ÿè®¡
        let filterStats = {
            originalCount: 0,
            filteredCount: 0,
            removedCount: 0
        };

        // è®¢å•ç¼–å·è§„èŒƒåŒ–å‡½æ•°ï¼šå¤„ç†ç©ºç™½å­—ç¬¦å’Œéšè—å­—ç¬¦
        function normalizeOrderNumber(value) {
            if (value === null || value === undefined || value === '') {
                return '';
            }
            
            // è½¬æ¢ä¸ºå­—ç¬¦ä¸²
            let str = value.toString();
            
            // ç§»é™¤æ‰€æœ‰ç±»å‹çš„ç©ºç™½å­—ç¬¦ï¼ˆåŒ…æ‹¬æ™®é€šç©ºæ ¼ã€åˆ¶è¡¨ç¬¦ã€æ¢è¡Œç¬¦ã€é›¶å®½ç©ºæ ¼ç­‰ï¼‰
            str = str.replace(/[\s\u200B-\u200D\uFEFF]/g, '');
            
            // ç§»é™¤å…¶ä»–æ§åˆ¶å­—ç¬¦
            str = str.replace(/[\x00-\x1F\x7F]/g, '');
            
            return str;
        }

        // æ£€æµ‹ç›¸ä¼¼è®¢å•ç¼–å·ï¼šæ‰¾å‡ºåªç›¸å·®åç¼€çš„è®¢å•å·
        function detectSimilarOrderNumbers(orderNumbers) {
            const similar = [];
            const sortedNumbers = [...orderNumbers].sort();
            
            for (let i = 0; i < sortedNumbers.length; i++) {
                for (let j = i + 1; j < sortedNumbers.length; j++) {
                    const num1 = sortedNumbers[i];
                    const num2 = sortedNumbers[j];
                    
                    // æ£€æŸ¥æ˜¯å¦ä¸€ä¸ªæ˜¯å¦ä¸€ä¸ªçš„å‰ç¼€
                    if (num2.startsWith(num1) && num2.length > num1.length) {
                        const suffix = num2.substring(num1.length);
                        // å¦‚æœåç¼€æ˜¯ "-æ•°å­—" æ ¼å¼ï¼Œåˆ™è®¤ä¸ºç›¸ä¼¼
                        if (/^-\d+$/.test(suffix)) {
                            similar.push({ base: num1, extended: num2, suffix: suffix });
                        }
                    }
                }
            }
            
            return similar;
        }

        // æ•°å€¼è§„èŒƒåŒ–å‡½æ•°ï¼šå¤„ç†æŠ˜æ‰£ç‡ç­‰ç™¾åˆ†æ¯”å­—æ®µçš„æµ®ç‚¹ç²¾åº¦é—®é¢˜
        function normalizePercentage(value) {
            if (value === null || value === undefined || value === '') {
                return value;
            }
            
            const num = parseFloat(value);
            if (isNaN(num)) {
                return value;
            }
            
            // ç»Ÿä¸€ä¿ç•™ä¸¤ä½å°æ•°ï¼ˆå››èˆäº”å…¥ï¼‰
            return parseFloat(num.toFixed(2));
        }

        // æ—¥æœŸè§£æå‡½æ•°ï¼šæ”¯æŒå¤šç§æ—¥æœŸæ ¼å¼
        function parseDate(value) {
            if (!value) return null;
            
            let str = value.toString().trim();
            
            // å°è¯•å°† "2025.9.15" æ ¼å¼è½¬æ¢ä¸ºæ ‡å‡†æ ¼å¼
            str = str.replace(/\./g, '/');
            
            // å°è¯•è§£ææ—¥æœŸ
            const date = new Date(str);
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆæ—¥æœŸ
            if (isNaN(date.getTime())) {
                return null;
            }
            
            return date;
        }

        // æ ¹æ®è®¢å•æ—¥æœŸæŸ¥æ‰¾åŒ¹é…çš„é”€å”®æ”¿ç­–å­è¡¨
        function findMatchingActivitySheet(orderDate) {
            if (!orderDate) return null;
            
            const orderTimestamp = parseDate(orderDate);
            if (!orderTimestamp) return null;
            
            const activitySheets = dataStore.policy.sheets.activity;
            
            for (let sheet of activitySheets) {
                const startTimestamp = parseDate(sheet.startDate);
                const endTimestamp = parseDate(sheet.endDate);
                
                if (startTimestamp && endTimestamp) {
                    if (orderTimestamp >= startTimestamp && orderTimestamp <= endTimestamp) {
                        return sheet;
                    }
                }
            }
            
            return null; // æœªæ‰¾åˆ°åŒ¹é…çš„æ”¿ç­–æ—¶é—´æ®µ
        }

        // å­—æ®µé…ç½®
        const fieldConfigs = {
            salesOrder: {
                title: 'é”€å”®è®¢å•',
                fields: [
                    { key: 'date', label: 'æ—¥æœŸ', matchKey: 'æ—¥æœŸ' },
                    { key: 'docNumber', label: 'å•æ®ç¼–å·', matchKey: 'å•æ®ç¼–å·' },
                    { key: 'userName', label: 'ç”¨æˆ·å§“å', matchKey: 'ç”¨æˆ·å§“å' },
                    { key: 'model', label: 'è§„æ ¼å‹å·', matchKey: 'è§„æ ¼å‹å·' },
                    { key: 'quantity', label: 'é”€å”®æ•°é‡', matchKey: 'é”€å”®æ•°é‡' },
                    { key: 'totalAmount', label: 'ä»·ç¨åˆè®¡', matchKey: 'ä»·ç¨åˆè®¡' },
                    { key: 'systemPrice', label: 'ç³»ç»Ÿå®šä»·', matchKey: 'ç³»ç»Ÿå®šä»·' },
                    { key: 'materialName', label: 'ç‰©æ–™åç§°', matchKey: 'ç‰©æ–™åç§°' },
                    { key: 'materialCategory', label: 'ç‰©æ–™ç±»åˆ«', matchKey: 'ç‰©æ–™ç±»åˆ«' },
                    { key: 'promoter', label: 'ä¿ƒé”€å‘˜', matchKey: 'ä¿ƒé”€å‘˜' },
                    { key: 'storeName', label: 'å®¢æˆ·åº—å', matchKey: 'å®¢æˆ·' },
                    { key: 'docType', label: 'å•æ®ç±»å‹', matchKey: 'å•æ®ç±»å‹' },
                    { key: 'paymentAmount', label: 'å›æ¬¾æ”¶æ¬¾é‡‘é¢', matchKey: 'ç´¯è®¡æ”¶æ¬¾é‡‘é¢' }
                ]
            },
            payment: {
                title: 'æ”¶æ¬¾å•',
                fields: [
                    { key: 'docNumber', label: 'å•æ®ç¼–å·', matchKey: 'é”€å”®è®¢å•å·' },
                    { key: 'amount', label: 'å›æ¬¾æ”¶æ¬¾é‡‘é¢', matchKey: 'æ”¶æ¬¾é‡‘é¢' }
                ],
                matchBy: 'docNumber'
            },
            commission: {
                title: 'å¸¦å•è´¹',
                fields: [
                    { key: 'docNumber', label: 'å•å·', matchKey: 'å•å·' },
                    { key: 'commissionRate', label: 'æ”¯ä»˜å¸¦å•ææˆç‚¹ä½', matchKey: 'æ”¯ä»˜å¸¦å•ææˆç‚¹ä½' },
                    { key: 'actualDiscount', label: 'å–å‡ºçš„å®é™…æŠ˜æ‰£', matchKey: 'æŠ˜æ‰£' }
                ],
                matchBy: 'docNumber'
            },
            policySpecialMachine: {
                title: 'æ”¿ç­–è¡¨ - ç‰¹ä»·æœºæ•´ç†',
                sheetName: 'ç‰¹ä»·æœºæ•´ç†',
                fields: [
                    { key: 'machineModel', label: 'æœºå‹', matchKey: 'æœºå‹' },
                    { key: 'largeType', label: 'å¤§ç±»å‹', matchKey: 'å¤§ç±»å‹' },
                    { key: 'commissionPlan', label: 'ç‰¹ä»·æœºææˆè®¡ç®—æ–¹æ¡ˆ', matchKey: 'ææˆè®¡ç®—' },
                    { key: 'minDiscount', label: 'ç‰¹ä»·æœºå…¬å¸æœ€ä½æŠ˜æ‰£', matchKey: 'å…¬å¸æœ€ä½æŠ˜æ‰£' }
                ],
                matchBy: 'model',
                matchKey: 'å‹å·'
            },
            policyChanet: {
                title: 'æ”¿ç­–è¡¨ - ä½³å°¼ç‰¹',
                sheetName: 'ä½³å°¼ç‰¹',
                fields: [
                    { key: 'chanetSpecial', label: 'ä½³å°¼ç‰¹ç‰¹ä»·', matchKey: 'ç‰¹ä»·' }
                ],
                matchBy: 'model',
                matchKey: 'å‹å·'
            },
            policyBoiler: {
                title: 'æ”¿ç­–è¡¨ - å£æŒ‚ç‚‰',
                sheetName: 'å£æŒ‚ç‚‰',
                fields: [
                    { key: 'boilerDiscount', label: 'å£æŒ‚ç‚‰é”€å”®æŠ˜æ‰£', matchKey: 'é”€å”®æŠ˜æ‰£' },
                    { key: 'boilerCommission', label: 'å£æŒ‚ç‚‰ææˆåŸå§‹', matchKey: 'ææˆ' }
                ],
                matchBy: 'model',
                matchKey: 'å‹å·'
            },
            policyActivity: {
                title: 'æ”¿ç­–è¡¨ - é”€å”®æ”¿ç­–',
                sheetName: 'æ´»åŠ¨',
                fields: [
                    { key: 'activityDiscount', label: 'é”€å”®æ”¿ç­–æŠ˜æ‰£ç‡', matchKey: 'æŠ˜æ‰£ç‡' },
                    { key: 'activityCommission', label: 'é”€å”®æ”¿ç­–ææˆåŸå§‹', matchKey: 'ææˆ' },
                    { key: 'activityExtra', label: 'é”€å”®æ”¿ç­–åŠ æåŸå§‹', matchKey: 'åŠ æ' },
                    { key: 'activityRequire', label: 'é”€å”®æ”¿ç­–è¦æ±‚', matchKey: 'åŠ æè¦æ±‚' }
                ],
                matchBy: 'model',
                matchKey: 'å‹å·'
            },
            policyPriceTable: {
                title: 'æ”¿ç­–è¡¨ - æ ‡ä»·',
                sheetName: 'æ ‡ä»·',
                fields: [
                    { key: 'largeType', label: 'å¤§ç±»å‹', matchKey: 'å¤§ç±»å‹' }
                ],
                matchBy: 'model',
                matchKey: 'å‹å·'
            }
        };

        // æ–‡ä»¶ä¸Šä¼ å¤„ç†
        document.getElementById('salesOrderFile').addEventListener('change', function(e) {
            handleFileUpload(e, 'salesOrder');
        });

        document.getElementById('paymentFile').addEventListener('change', function(e) {
            handleFileUpload(e, 'payment');
        });

        document.getElementById('commissionFile').addEventListener('change', function(e) {
            handleFileUpload(e, 'commission');
        });

        document.getElementById('policyFile').addEventListener('change', function(e) {
            handleFileUpload(e, 'policy');
        });

        function handleFileUpload(event, type) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array' });
                
                const boxId = type + 'Box';
                const infoId = type + 'Info';
                
                document.getElementById(boxId).classList.add('has-file');
                document.getElementById(infoId).style.display = 'block';
                document.getElementById(infoId).textContent = `âœ“ ${file.name}`;
                
                if (type === 'policy') {
                    // æ”¿ç­–è¡¨ç‰¹æ®Šå¤„ç†ï¼šåŠ è½½æ‰€æœ‰å­è¡¨
                    dataStore.policy.workbook = workbook;
                    loadPolicySheets(workbook);
                } else {
                    // æ˜¾ç¤ºå­è¡¨é€‰æ‹©å™¨
                    const selectorId = type + 'SheetSelector';
                    const selectId = type + 'Sheet';
                    
                    const sheetSelector = document.getElementById(selectorId);
                    sheetSelector.style.display = 'block';
                    
                    const select = document.getElementById(selectId);
                    select.innerHTML = '';
                    workbook.SheetNames.forEach((sheetName, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = sheetName;
                        select.appendChild(option);
                    });

                    // é»˜è®¤åŠ è½½ç¬¬ä¸€ä¸ªå­è¡¨
                    select.onchange = function() {
                        loadSheet(workbook, select.value, type);
                    };
                    
                    loadSheet(workbook, 0, type);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function loadSheet(workbook, sheetIndex, type) {
            const sheetName = workbook.SheetNames[sheetIndex];
            const worksheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            
            if (jsonData.length === 0) return;

            // è·³è¿‡å‰é¢çš„ç©ºç™½è¡Œï¼Œæ‰¾åˆ°å®é™…è¡¨å¤´
            let headerRowIndex = 0;
            for (let i = 0; i < Math.min(jsonData.length, 5); i++) {
                const row = jsonData[i];
                // æ£€æŸ¥è¿™ä¸€è¡Œæ˜¯å¦æœ‰æœ‰æ•ˆå†…å®¹ï¼ˆéç©ºä¸”éå…¨ç©ºï¼‰
                const hasContent = row.some(cell => cell !== null && cell !== undefined && cell !== '' && cell !== 0);
                if (hasContent) {
                    // æ£€æŸ¥æ˜¯å¦åƒè¡¨å¤´ï¼ˆå­—ç¬¦ä¸²å†…å®¹è¾ƒå¤šï¼‰
                    const stringCells = row.filter(cell => typeof cell === 'string' && cell.trim() !== '');
                    if (stringCells.length >= 2) {
                        headerRowIndex = i;
                        break;
                    }
                }
            }

            // ç¬¬ä¸€è¡Œä½œä¸ºè¡¨å¤´
            const headers = jsonData[headerRowIndex];
            const rows = jsonData.slice(headerRowIndex + 1).filter(row => row.some(cell => cell !== null && cell !== undefined && cell !== ''));

            dataStore[type].headers = headers;
            dataStore[type].data = rows;
            dataStore[type].workbook = workbook;

            console.log(`${type} è¯»å–æˆåŠŸ: è¡¨å¤´è¡Œ=${headerRowIndex}, æ•°æ®è¡Œæ•°=${rows.length}`);
            console.log(`${type} è¡¨å¤´:`, headers);

            updateMappingUI();
            checkReadyToMatch();
        }

        function loadPolicySheets(workbook) {
            // éæ´»åŠ¨ç±»å­è¡¨æ˜ å°„ï¼ˆä¿æŒåŸé€»è¾‘ï¼‰
            const sheetMappings = [
                { configKey: 'policySpecialMachine', storeKey: 'specialMachine', name: 'ç‰¹ä»·æœºæ•´ç†' },
                { configKey: 'policyChanet', storeKey: 'chanet', name: 'ä½³å°¼ç‰¹' },
                { configKey: 'policyBoiler', storeKey: 'boiler', name: 'å£æŒ‚ç‚‰' },
                { configKey: 'policyPriceTable', storeKey: 'priceTable', name: 'æ ‡ä»·' }
            ];

            // åŠ è½½éæ´»åŠ¨ç±»å­è¡¨
            sheetMappings.forEach(mapping => {
                const sheetIndex = workbook.SheetNames.indexOf(mapping.name);
                if (sheetIndex !== -1) {
                    const worksheet = workbook.Sheets[mapping.name];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    
                    if (jsonData.length > 0) {
                        // è·³è¿‡å‰é¢çš„ç©ºç™½è¡Œï¼Œæ‰¾åˆ°å®é™…è¡¨å¤´
                        let headerRowIndex = 0;
                        for (let i = 0; i < Math.min(jsonData.length, 5); i++) {
                            const row = jsonData[i];
                            const hasContent = row.some(cell => cell !== null && cell !== undefined && cell !== '' && cell !== 0);
                            if (hasContent) {
                                const stringCells = row.filter(cell => typeof cell === 'string' && cell.trim() !== '');
                                if (stringCells.length >= 2) {
                                    headerRowIndex = i;
                                    break;
                                }
                            }
                        }
                        
                        const headers = jsonData[headerRowIndex];
                        const rows = jsonData.slice(headerRowIndex + 1).filter(row => row.some(cell => cell !== null && cell !== undefined && cell !== ''));
                        
                        dataStore.policy.sheets[mapping.storeKey].headers = headers;
                        dataStore.policy.sheets[mapping.storeKey].data = rows;
                        
                        console.log(`æ”¿ç­–è¡¨-${mapping.name} è¯»å–æˆåŠŸ: è¡¨å¤´è¡Œ=${headerRowIndex}, æ•°æ®è¡Œæ•°=${rows.length}`);
                    }
                }
            });

            // åŠ è½½æ‰€æœ‰ä»¥"æ´»åŠ¨"å¼€å¤´çš„å­è¡¨ï¼ˆæ”¯æŒå¤šä¸ªæ—¶é—´æ®µï¼‰
            dataStore.policy.sheets.activity = []; // æ¸…ç©ºæ´»åŠ¨æ•°ç»„
            
            workbook.SheetNames.forEach(sheetName => {
                // è¯†åˆ«æ‰€æœ‰ä»¥"æ´»åŠ¨"å¼€å¤´çš„å­è¡¨
                if (sheetName.startsWith('æ´»åŠ¨')) {
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    
                    if (jsonData.length > 0) {
                        // è·³è¿‡å‰é¢çš„ç©ºç™½è¡Œï¼Œæ‰¾åˆ°å®é™…è¡¨å¤´
                        let headerRowIndex = 0;
                        for (let i = 0; i < Math.min(jsonData.length, 5); i++) {
                            const row = jsonData[i];
                            const hasContent = row.some(cell => cell !== null && cell !== undefined && cell !== '' && cell !== 0);
                            if (hasContent) {
                                const stringCells = row.filter(cell => typeof cell === 'string' && cell.trim() !== '');
                                if (stringCells.length >= 2) {
                                    headerRowIndex = i;
                                    break;
                                }
                            }
                        }
                        
                        const headers = jsonData[headerRowIndex];
                        const rows = jsonData.slice(headerRowIndex + 1).filter(row => row.some(cell => cell !== null && cell !== undefined && cell !== ''));
                        
                        // ä»ç¬¬ä¸€è¡Œæ•°æ®ä¸­æå–å¼€å§‹å’Œç»“æŸæ—¶é—´ï¼ˆMåˆ—å’ŒNåˆ—ï¼Œç´¢å¼•12å’Œ13ï¼‰
                        let startDate = null;
                        let endDate = null;
                        
                        if (rows.length > 0) {
                            const firstRow = rows[0];
                            // Måˆ—ï¼šæ”¿ç­–å¼€å§‹æ—¶é—´ï¼ˆç´¢å¼•12ï¼‰
                            if (firstRow[12]) {
                                startDate = firstRow[12];
                            }
                            // Nåˆ—ï¼šæ”¿ç­–ç»“æŸæ—¶é—´ï¼ˆç´¢å¼•13ï¼‰
                            if (firstRow[13]) {
                                endDate = firstRow[13];
                            }
                        }
                        
                        // æ·»åŠ åˆ°æ´»åŠ¨æ•°ç»„
                        dataStore.policy.sheets.activity.push({
                            sheetName: sheetName,
                            startDate: startDate,
                            endDate: endDate,
                            headers: headers,
                            data: rows
                        });
                        
                        console.log(`æ”¿ç­–è¡¨-${sheetName} è¯»å–æˆåŠŸ: è¡¨å¤´è¡Œ=${headerRowIndex}, æ•°æ®è¡Œæ•°=${rows.length}, æ—¶é—´æ®µ=${startDate} è‡³ ${endDate}`);
                    }
                }
            });

            console.log(`å…±åŠ è½½ ${dataStore.policy.sheets.activity.length} ä¸ªæ´»åŠ¨å­è¡¨`);

            // åœ¨ç•Œé¢ä¸Šæ˜¾ç¤ºå·²åŠ è½½çš„æ´»åŠ¨å­è¡¨æ—¶é—´æ®µä¿¡æ¯
            displayActivitySheetsInfo();

            updateMappingUI();
            checkReadyToMatch();
        }

        // æ˜¾ç¤ºå·²åŠ è½½çš„æ´»åŠ¨å­è¡¨æ—¶é—´æ®µä¿¡æ¯
        function displayActivitySheetsInfo() {
            const infoElement = document.getElementById('policyInfo');
            if (!infoElement) return;
            
            const activitySheets = dataStore.policy.sheets.activity;
            if (activitySheets.length === 0) {
                infoElement.innerHTML = 'âœ“ æ”¿ç­–è¡¨å·²åŠ è½½ï¼ˆæœªæ‰¾åˆ°æ´»åŠ¨å­è¡¨ï¼‰';
                return;
            }
            
            let infoHtml = `âœ“ æ”¿ç­–è¡¨å·²åŠ è½½<br><small style="color: #4299e1; margin-top: 4px; display: block;">`;
            infoHtml += `ğŸ“… é”€å”®æ”¿ç­–æ—¶é—´æ®µï¼ˆ${activitySheets.length}ä¸ªï¼‰ï¼š<br>`;
            
            let hasWarning = false;
            activitySheets.forEach((sheet, index) => {
                if (sheet.startDate && sheet.endDate) {
                    infoHtml += `  ${index + 1}. ${sheet.sheetName}: ${sheet.startDate} ~ ${sheet.endDate}<br>`;
                } else {
                    infoHtml += `  ${index + 1}. ${sheet.sheetName}: <span style="color: #ed8936;">æœªè®¾ç½®æ—¶é—´æ®µï¼ˆå°†åŒ¹é…æ‰€æœ‰è®¢å•ï¼‰</span><br>`;
                    hasWarning = true;
                }
            });
            
            if (hasWarning) {
                infoHtml += `<br><span style="color: #ed8936;">âš ï¸ æç¤ºï¼šæœªè®¾ç½®æ—¶é—´æ®µçš„å­è¡¨å°†å¯¹æ‰€æœ‰è®¢å•ç”Ÿæ•ˆï¼Œä¸ä¼šæ ¹æ®æ—¥æœŸç­›é€‰ã€‚</span><br>`;
                infoHtml += `<span style="color: #718096;">å»ºè®®åœ¨Måˆ—å’ŒNåˆ—è®¾ç½®æ—¶é—´æ®µä»¥å¯ç”¨æ—¥æœŸåŒ¹é…åŠŸèƒ½ã€‚</span>`;
            }
            
            infoHtml += `</small>`;
            infoElement.innerHTML = infoHtml;
        }

        function updateMappingUI() {
            const container = document.getElementById('mappingContainer');
            container.innerHTML = '';

            // é”€å”®è®¢å•æ˜ å°„
            if (dataStore.salesOrder.data) {
                createMappingSection('salesOrder', fieldConfigs.salesOrder, dataStore.salesOrder.headers, container);
            }

            // æ”¶æ¬¾å•æ˜ å°„
            if (dataStore.payment.data) {
                createMappingSection('payment', fieldConfigs.payment, dataStore.payment.headers, container);
            }

            // å¸¦å•è´¹æ˜ å°„
            if (dataStore.commission.data) {
                createMappingSection('commission', fieldConfigs.commission, dataStore.commission.headers, container);
            }

            // æ”¿ç­–è¡¨å„å­è¡¨æ˜ å°„
            if (dataStore.policy.workbook) {
                const policyConfigs = [
                    { key: 'policySpecialMachine', storeKey: 'specialMachine' },
                    { key: 'policyChanet', storeKey: 'chanet' },
                    { key: 'policyBoiler', storeKey: 'boiler' },
                    { key: 'policyPriceTable', storeKey: 'priceTable' }
                ];

                policyConfigs.forEach(cfg => {
                    const sheetData = dataStore.policy.sheets[cfg.storeKey];
                    if (sheetData.data && sheetData.data.length > 0) {
                        createMappingSection(cfg.key, fieldConfigs[cfg.key], sheetData.headers, container);
                    }
                });

                // ä¸ºæ¯ä¸ªæ´»åŠ¨å­è¡¨åˆ›å»ºæ˜ å°„åŒºåŸŸ
                if (dataStore.policy.sheets.activity.length > 0) {
                    dataStore.policy.sheets.activity.forEach((activitySheet, index) => {
                        const config = {
                            ...fieldConfigs.policyActivity,
                            title: `æ”¿ç­–è¡¨ - ${activitySheet.sheetName}${activitySheet.startDate && activitySheet.endDate ? ` (${activitySheet.startDate} ~ ${activitySheet.endDate})` : ''}`
                        };
                        createMappingSection(`policyActivity_${index}`, config, activitySheet.headers, container);
                    });
                }
            }
        }

        function createMappingSection(configKey, config, headers, container) {
            const section = document.createElement('div');
            section.className = 'mapping-section';

            const title = document.createElement('div');
            title.className = 'mapping-section-title';
            title.textContent = config.title;
            section.appendChild(title);

            const grid = document.createElement('div');
            grid.className = 'mapping-grid';

            config.fields.forEach(field => {
                const row = document.createElement('div');
                row.className = 'mapping-row';

                const label = document.createElement('div');
                label.className = 'mapping-label';
                label.textContent = field.label;
                row.appendChild(label);

                const select = document.createElement('select');
                select.id = `${configKey}_${field.key}`;
                
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = '-- è¯·é€‰æ‹©åˆ— --';
                select.appendChild(defaultOption);

                // æ™ºèƒ½åŒ¹é…
                let matchedIndex = -1;
                headers.forEach((header, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = header || `åˆ—${index + 1}`;
                    
                    // æ™ºèƒ½åŒ¹é…
                    if (matchedIndex === -1 && header && field.matchKey) {
                        const headerStr = header.toString().trim();
                        if (headerStr === field.matchKey || 
                            headerStr.includes(field.matchKey)) {
                            matchedIndex = index;
                            option.selected = true;
                        }
                    }
                    
                    select.appendChild(option);
                });

                select.addEventListener('change', checkReadyToMatch);
                row.appendChild(select);

                const source = document.createElement('div');
                source.className = 'mapping-source';
                source.textContent = config.title.split(' - ')[0];
                row.appendChild(source);

                grid.appendChild(row);
            });

            section.appendChild(grid);
            container.appendChild(section);
        }

        function checkReadyToMatch() {
            const ready = dataStore.salesOrder.data !== null &&
                         document.getElementById('salesOrder_docNumber')?.value !== '';
            
            document.getElementById('matchBtn').disabled = !ready;
        }

        function performMatch() {
            const btn = document.getElementById('matchBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="loading"></span>åŒ¹é…ä¸­...';

            setTimeout(() => {
                try {
                    // è·å–æ‰€æœ‰å­—æ®µæ˜ å°„
                    const mappings = extractMappings();
                    
                    // æ„å»ºç´¢å¼•
                    const indexes = buildIndexes(mappings);
                    
                    // æ‰§è¡ŒåŒ¹é…
                    matchResult = [];
                    const stats = { 
                        payment: 0, 
                        commission: 0, 
                        specialMachine: 0,
                        chanet: 0,
                        boiler: 0,
                        activity: 0,
                        priceTable: 0
                    };

                    // æ£€æµ‹é”€å”®è®¢å•ä¸­çš„ç›¸ä¼¼è®¢å•å·
                    const allSalesOrderNumbers = dataStore.salesOrder.data
                        .map(row => {
                            const colIndex = mappings.salesOrder.docNumber;
                            if (colIndex !== undefined && row[colIndex]) {
                                return normalizeOrderNumber(row[colIndex]);
                            }
                            return '';
                        })
                        .filter(num => num !== '');
                    
                    const similarSales = detectSimilarOrderNumbers([...new Set(allSalesOrderNumbers)]);
                    if (similarSales.length > 0) {
                        console.warn('é”€å”®è®¢å•ä¸­å‘ç°ç›¸ä¼¼è®¢å•å·:', similarSales);
                        matchDiagnostics.similarOrderNumbers.push(...similarSales.map(s => ({
                            source: 'é”€å”®è®¢å•',
                            ...s
                        })));
                    }
                    
                    // é—¨åº—è¿‡æ»¤ï¼šåªä¿ç•™ç™½åå•ä¸­çš„é—¨åº—æ•°æ®
                    filterStats.originalCount = dataStore.salesOrder.data.length;
                    const storeNameColIndex = mappings.salesOrder.storeName;
                    const filteredSalesData = dataStore.salesOrder.data.filter(row => {
                        if (storeNameColIndex === undefined) {
                            return true; // å¦‚æœæ²¡æœ‰æ˜ å°„å®¢æˆ·åº—åå­—æ®µï¼Œä¿ç•™æ‰€æœ‰æ•°æ®
                        }
                        const storeName = row[storeNameColIndex];
                        if (!storeName) {
                            return false; // ç©ºåº—åä¸ä¿ç•™
                        }
                        const storeNameStr = storeName.toString().trim();
                        // æ£€æŸ¥æ˜¯å¦åœ¨ç™½åå•ä¸­
                        return storeWhitelist.some(whiteStore => {
                            // ç²¾ç¡®åŒ¹é…æˆ–åŒ…å«åŒ¹é…
                            return storeNameStr === whiteStore || 
                                   storeNameStr.includes(whiteStore) || 
                                   whiteStore.includes(storeNameStr);
                        });
                    });
                    filterStats.filteredCount = filteredSalesData.length;
                    filterStats.removedCount = filterStats.originalCount - filterStats.filteredCount;
                    
                    console.log(`é—¨åº—è¿‡æ»¤ï¼šåŸå§‹ ${filterStats.originalCount} æ¡ï¼Œä¿ç•™ ${filterStats.filteredCount} æ¡ï¼Œè¿‡æ»¤ ${filterStats.removedCount} æ¡`);
                    
                    filteredSalesData.forEach(row => {
                        const record = {};
                        
                        // æå–é”€å”®è®¢å•å­—æ®µ
                        fieldConfigs.salesOrder.fields.forEach(field => {
                            const colIndex = mappings.salesOrder[field.key];
                            record[field.label] = colIndex !== undefined ? (row[colIndex] || '') : '';
                        });

                        // è·å–åŒ¹é…é”®ï¼ˆä½¿ç”¨è§„èŒƒåŒ–ï¼‰
                        const docNumberRaw = record['å•æ®ç¼–å·'];
                        const docNumber = normalizeOrderNumber(docNumberRaw);
                        const model = record['è§„æ ¼å‹å·'] ? record['è§„æ ¼å‹å·'].toString().trim() : '';

                        // åŒ¹é…æ”¶æ¬¾é‡‘é¢ - æ–°é€»è¾‘ï¼š
                        // 1. å…ˆæ ¹æ®æ”¶æ¬¾å•åŒ¹é…"è¡¨å¤´-å®æ”¶é‡‘é¢"
                        // 2. å¦‚æœé”€å”®æ•°é‡<0ï¼ˆé€€æ¬¾è®¢å•ï¼‰ï¼Œå›æ¬¾æ”¶æ¬¾é‡‘é¢=ä»·ç¨åˆè®¡
                        // 3. å‰©ä½™æ²¡æœ‰åŒ¹é…åˆ°çš„ï¼Œå›æ¬¾æ”¶æ¬¾é‡‘é¢å¡«0
                        const quantity = parseFloat(record['é”€å”®æ•°é‡']) || 0;
                        let finalPayment = '';
                        let matchedFromPayment = false;
                        
                        // è§„åˆ™1: å…ˆå°è¯•åŒ¹é…æ”¶æ¬¾å•ï¼ˆä½¿ç”¨è§„èŒƒåŒ–åçš„è®¢å•å·è¿›è¡Œç²¾ç¡®åŒ¹é…ï¼‰
                        if (indexes.payment && docNumber && indexes.payment[docNumber] !== undefined) {
                            finalPayment = indexes.payment[docNumber];
                            matchedFromPayment = true;
                            stats.payment++;
                            
                            // è®°å½•åŒ¹é…ä¿¡æ¯
                            matchDiagnostics.paymentMatches.push({
                                orderNumber: docNumber,
                                orderNumberRaw: docNumberRaw,
                                paymentAmount: finalPayment,
                                matchType: 'æ”¶æ¬¾å•åŒ¹é…'
                            });
                        }
                        
                        // è§„åˆ™2: é€€æ¬¾è®¢å•ï¼ˆé”€å”®æ•°é‡<0ï¼‰ä½¿ç”¨ä»·ç¨åˆè®¡
                        if (quantity < 0) {
                            finalPayment = record['ä»·ç¨åˆè®¡'] || 0;
                            if (!matchedFromPayment) {
                                matchDiagnostics.paymentMatches.push({
                                    orderNumber: docNumber,
                                    orderNumberRaw: docNumberRaw,
                                    paymentAmount: finalPayment,
                                    matchType: 'é€€æ¬¾è®¢å•ï¼ˆä½¿ç”¨ä»·ç¨åˆè®¡ï¼‰'
                                });
                            }
                        }
                        
                        // è§„åˆ™3: å‰©ä½™æœªåŒ¹é…çš„å¡«0
                        if (!finalPayment && finalPayment !== 0) {
                            finalPayment = 0;
                            if (!matchedFromPayment && quantity >= 0 && docNumber) {
                                // è®°å½•æœªåŒ¹é…çš„è®¢å•
                                matchDiagnostics.unmatchedOrders.push({
                                    orderNumber: docNumber,
                                    orderNumberRaw: docNumberRaw,
                                    userName: record['ç”¨æˆ·å§“å'],
                                    model: model,
                                    totalAmount: record['ä»·ç¨åˆè®¡']
                                });
                            }
                        }
                        
                        record['å›æ¬¾æ”¶æ¬¾é‡‘é¢'] = finalPayment;

                        // åŒ¹é…å¸¦å•è´¹ï¼ˆæŒ‰å•æ®ç¼–å·ï¼‰
                        if (mappings.commission && indexes.commission && indexes.commission[docNumber]) {
                            const commData = indexes.commission[docNumber];
                            fieldConfigs.commission.fields.forEach(field => {
                                // è·³è¿‡å•å·å­—æ®µï¼Œå› ä¸ºå·²ç»æœ‰å•æ®ç¼–å·äº†
                                if (field.key !== 'docNumber') {
                                    record[field.label] = commData[field.key] || '';
                                }
                            });
                            stats.commission++;
                        } else if (mappings.commission) {
                            fieldConfigs.commission.fields.forEach(field => {
                                if (field.key !== 'docNumber') {
                                    record[field.label] = '';
                                }
                            });
                        }

                        // åŒ¹é…æ”¿ç­–è¡¨ - ç‰¹ä»·æœºæ•´ç†ï¼ˆæŒ‰è§„æ ¼å‹å·ï¼‰
                        if (mappings.policySpecialMachine && indexes.policySpecialMachine[model]) {
                            const policyData = indexes.policySpecialMachine[model];
                            fieldConfigs.policySpecialMachine.fields.forEach(field => {
                                record[field.label] = policyData[field.key] || '';
                            });
                            stats.specialMachine++;
                        } else if (mappings.policySpecialMachine) {
                            fieldConfigs.policySpecialMachine.fields.forEach(field => {
                                record[field.label] = '';
                            });
                        }

                        // åŒ¹é…æ”¿ç­–è¡¨ - ä½³å°¼ç‰¹ï¼ˆæŒ‰è§„æ ¼å‹å·ï¼‰
                        if (mappings.policyChanet && indexes.policyChanet[model]) {
                            const policyData = indexes.policyChanet[model];
                            fieldConfigs.policyChanet.fields.forEach(field => {
                                record[field.label] = policyData[field.key] || '';
                            });
                            stats.chanet++;
                        } else if (mappings.policyChanet) {
                            fieldConfigs.policyChanet.fields.forEach(field => {
                                record[field.label] = '';
                            });
                        }

                        // åŒ¹é…æ”¿ç­–è¡¨ - å£æŒ‚ç‚‰ï¼ˆæŒ‰è§„æ ¼å‹å·ï¼‰
                        if (mappings.policyBoiler && indexes.policyBoiler[model]) {
                            const policyData = indexes.policyBoiler[model];
                            fieldConfigs.policyBoiler.fields.forEach(field => {
                                record[field.label] = policyData[field.key] || '';
                            });
                            stats.boiler++;
                        } else if (mappings.policyBoiler) {
                            fieldConfigs.policyBoiler.fields.forEach(field => {
                                record[field.label] = '';
                            });
                        }

                        // åŒ¹é…æ”¿ç­–è¡¨ - é”€å”®æ”¿ç­–ï¼ˆæ ¹æ®è®¢å•æ—¥æœŸåŒ¹é…å¯¹åº”æ—¶é—´æ®µçš„æ”¿ç­–ï¼‰
                        if (mappings.policyActivity && Array.isArray(indexes.policyActivity)) {
                            const orderDate = record['æ—¥æœŸ'];
                            let policyData = null;
                            let matchedSheet = null;
                            let matchType = '';
                            let dateMatchedSheet = null; // è®°å½•æ—¥æœŸåŒ¹é…åˆ°çš„å­è¡¨ï¼ˆå³ä½¿å‹å·ä¸å­˜åœ¨ï¼‰
                            
                            // éå†æ‰€æœ‰æ´»åŠ¨å­è¡¨ï¼Œæ‰¾åˆ°æ—¥æœŸåŒ¹é…çš„é‚£ä¸ª
                            for (let activitySheet of indexes.policyActivity) {
                                if (!activitySheet) continue;
                                
                                const orderTimestamp = parseDate(orderDate);
                                const startTimestamp = parseDate(activitySheet.startDate);
                                const endTimestamp = parseDate(activitySheet.endDate);
                                
                                // å¦‚æœæœ‰æ—¶é—´æ®µï¼Œåˆ™è¿›è¡Œæ—¥æœŸåŒ¹é…
                                if (orderTimestamp && startTimestamp && endTimestamp) {
                                    if (orderTimestamp >= startTimestamp && orderTimestamp <= endTimestamp) {
                                        // æ‰¾åˆ°æ—¥æœŸåŒ¹é…çš„å­è¡¨
                                        dateMatchedSheet = activitySheet;
                                        
                                        // ä»è¯¥å­è¡¨çš„ç´¢å¼•ä¸­æŸ¥æ‰¾å‹å·
                                        if (activitySheet.index[model]) {
                                            policyData = activitySheet.index[model];
                                            matchedSheet = activitySheet;
                                            matchType = 'date';
                                            break;
                                        }
                                        // æ‰¾åˆ°äº†æ—¥æœŸåŒ¹é…çš„è¡¨ï¼Œä½†æ²¡æœ‰è¿™ä¸ªå‹å·ï¼Œç»§ç»­çœ‹æ˜¯å¦æœ‰å…¶ä»–æ—¶é—´æ®µ
                                    }
                                } 
                                // å¦‚æœæ²¡æœ‰æ—¶é—´æ®µè®¾ç½®ï¼Œç›´æ¥åŒ¹é…å‹å·ï¼ˆå‘åå…¼å®¹ï¼‰
                                else if (!startTimestamp || !endTimestamp) {
                                    if (activitySheet.index[model]) {
                                        policyData = activitySheet.index[model];
                                        matchedSheet = activitySheet;
                                        matchType = 'direct';
                                        break;
                                    }
                                }
                            }
                            
                            if (policyData) {
                                fieldConfigs.policyActivity.fields.forEach(field => {
                                    record[field.label] = policyData[field.key] || '';
                                });
                                
                                // æ·»åŠ åŒ¹é…è¯´æ˜
                                if (matchType === 'date') {
                                    record['é”€å”®æ”¿ç­–åŒ¹é…è¯´æ˜'] = `åŒ¹é…æˆåŠŸï¼š${matchedSheet.sheetName}ï¼ˆ${matchedSheet.startDate} ~ ${matchedSheet.endDate}ï¼‰`;
                                } else if (matchType === 'direct') {
                                    record['é”€å”®æ”¿ç­–åŒ¹é…è¯´æ˜'] = `åŒ¹é…æˆåŠŸï¼š${matchedSheet.sheetName}ï¼ˆæœªè®¾ç½®æ—¶é—´æ®µï¼‰`;
                                }
                                
                                stats.activity++;
                            } else {
                                fieldConfigs.policyActivity.fields.forEach(field => {
                                    record[field.label] = '';
                                });
                                
                                // æœªåŒ¹é…æ—¶çš„ç²¾ç¡®è¯´æ˜
                                if (dateMatchedSheet) {
                                    // æƒ…å†µ1ï¼šæ‰¾åˆ°äº†æ—¥æœŸåŒ¹é…çš„æ”¿ç­–è¡¨ï¼Œä½†å‹å·ä¸åœ¨è¡¨ä¸­
                                    record['é”€å”®æ”¿ç­–åŒ¹é…è¯´æ˜'] = `æœªåŒ¹é…ï¼šå‹å·"${model}"ä¸åœ¨æ”¿ç­–è¡¨"${dateMatchedSheet.sheetName}"ï¼ˆ${dateMatchedSheet.startDate} ~ ${dateMatchedSheet.endDate}ï¼‰ä¸­`;
                                } else if (indexes.policyActivity.length > 0) {
                                    // æƒ…å†µ2ï¼šæœ‰æ”¿ç­–è¡¨ï¼Œä½†è®¢å•æ—¥æœŸä¸åœ¨ä»»ä½•æ—¶é—´æ®µå†…
                                    const hasTimeRange = indexes.policyActivity.some(s => s && s.startDate && s.endDate);
                                    if (hasTimeRange) {
                                        // åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„æ—¶é—´æ®µ
                                        const periods = indexes.policyActivity
                                            .filter(s => s && s.startDate && s.endDate)
                                            .map(s => `${s.startDate}~${s.endDate}`)
                                            .join('ã€');
                                        record['é”€å”®æ”¿ç­–åŒ¹é…è¯´æ˜'] = `æœªåŒ¹é…ï¼šè®¢å•æ—¥æœŸ"${orderDate || 'ç¼ºå¤±'}"ä¸åœ¨ä»»ä½•æ”¿ç­–æ—¶é—´æ®µå†…ï¼ˆå¯ç”¨æ—¶é—´æ®µï¼š${periods}ï¼‰`;
                                    } else {
                                        // æ²¡æœ‰è®¾ç½®æ—¶é—´æ®µï¼Œå‹å·ä¹Ÿä¸åœ¨è¡¨ä¸­
                                        record['é”€å”®æ”¿ç­–åŒ¹é…è¯´æ˜'] = `æœªåŒ¹é…ï¼šå‹å·"${model}"ä¸åœ¨æ”¿ç­–è¡¨ä¸­`;
                                    }
                                } else {
                                    record['é”€å”®æ”¿ç­–åŒ¹é…è¯´æ˜'] = 'æœªåŒ¹é…ï¼šæœªä¸Šä¼ é”€å”®æ”¿ç­–è¡¨';
                                }
                            }
                        } else if (mappings.policyActivity) {
                            fieldConfigs.policyActivity.fields.forEach(field => {
                                record[field.label] = '';
                            });
                            record['é”€å”®æ”¿ç­–åŒ¹é…è¯´æ˜'] = 'æœªåŒ¹é…ï¼šé”€å”®æ”¿ç­–å­—æ®µæ˜ å°„æœªé…ç½®';
                        } else {
                            record['é”€å”®æ”¿ç­–åŒ¹é…è¯´æ˜'] = 'æœªåŒ¹é…ï¼šæœªä¸Šä¼ é”€å”®æ”¿ç­–è¡¨';
                        }

                        // åŒ¹é…æ”¿ç­–è¡¨ - æ ‡ä»·ï¼ˆæŒ‰è§„æ ¼å‹å·ï¼‰
                        if (mappings.policyPriceTable && indexes.policyPriceTable[model]) {
                            const policyData = indexes.policyPriceTable[model];
                            fieldConfigs.policyPriceTable.fields.forEach(field => {
                                record[field.label] = policyData[field.key] || '';
                            });
                            stats.priceTable++;
                        } else if (mappings.policyPriceTable) {
                            fieldConfigs.policyPriceTable.fields.forEach(field => {
                                record[field.label] = '';
                            });
                        }

                        matchResult.push(record);
                    });

                    // æŸ¥æ‰¾æ”¶æ¬¾å•ä¸­æœªåŒ¹é…çš„è®°å½•
                    if (indexes.payment) {
                        const matchedPaymentOrderNumbers = new Set(
                            matchDiagnostics.paymentMatches
                                .filter(m => m.matchType === 'æ”¶æ¬¾å•åŒ¹é…')
                                .map(m => m.orderNumber)
                        );
                        
                        Object.keys(indexes.payment).forEach(paymentOrderNumber => {
                            if (!matchedPaymentOrderNumbers.has(paymentOrderNumber)) {
                                matchDiagnostics.unmatchedPayments.push({
                                    orderNumber: paymentOrderNumber,
                                    paymentAmount: indexes.payment[paymentOrderNumber]
                                });
                            }
                        });
                    }

                    // è¯†åˆ«é€€è´§å’Œå›½è¡¥è®¢å•
                    const guobuStats = identifyGuoBu(matchResult);
                    stats.return = guobuStats.returnCount;
                    stats.guobu = guobuStats.guobuCount;
                    stats.nonGuobu = guobuStats.nonGuobuCount;

                    // æ˜¾ç¤ºç»“æœ
                    displayResult(stats);
                    
                    btn.innerHTML = 'é‡æ–°åŒ¹é…';
                    btn.disabled = false;
                } catch (error) {
                    alert('åŒ¹é…è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: ' + error.message);
                    console.error(error);
                    btn.innerHTML = 'å¼€å§‹åŒ¹é…';
                    btn.disabled = false;
                }
            }, 500);
        }

        function extractMappings() {
            const mappings = {};
            
            // æå–æ‰€æœ‰é…ç½®çš„å­—æ®µæ˜ å°„ï¼ˆé™¤äº†æ´»åŠ¨ï¼‰
            Object.keys(fieldConfigs).forEach(configKey => {
                if (configKey === 'policyActivity') return; // æ´»åŠ¨å•ç‹¬å¤„ç†
                
                const config = fieldConfigs[configKey];
                const mapping = {};
                let hasMapping = false;
                
                config.fields.forEach(field => {
                    const select = document.getElementById(`${configKey}_${field.key}`);
                    if (select && select.value !== '') {
                        mapping[field.key] = parseInt(select.value);
                        hasMapping = true;
                    }
                });
                
                if (hasMapping) {
                    mappings[configKey] = mapping;
                }
            });
            
            // æå–æ‰€æœ‰æ´»åŠ¨å­è¡¨çš„æ˜ å°„
            if (dataStore.policy.sheets.activity.length > 0) {
                mappings.policyActivity = []; // æ”¹ä¸ºæ•°ç»„
                dataStore.policy.sheets.activity.forEach((activitySheet, index) => {
                    const mapping = {};
                    let hasMapping = false;
                    
                    fieldConfigs.policyActivity.fields.forEach(field => {
                        const select = document.getElementById(`policyActivity_${index}_${field.key}`);
                        if (select && select.value !== '') {
                            mapping[field.key] = parseInt(select.value);
                            hasMapping = true;
                        }
                    });
                    
                    if (hasMapping) {
                        mappings.policyActivity.push(mapping);
                    } else {
                        mappings.policyActivity.push(null);
                    }
                });
            }
            
            return mappings;
        }

        function buildIndexes(mappings) {
            const indexes = {};
            
            // é‡ç½®è¯Šæ–­ä¿¡æ¯
            matchDiagnostics = {
                similarOrderNumbers: [],
                unmatchedOrders: [],
                unmatchedPayments: [],
                paymentMatches: []
            };
            
            // æ”¶æ¬¾å•ç´¢å¼•ï¼ˆæŒ‰å•æ®ç¼–å·æ±‚å’Œï¼‰
            if (mappings.payment && dataStore.payment.data) {
                indexes.payment = {};
                const paymentOrderNumbers = [];
                
                dataStore.payment.data.forEach(row => {
                    const docNumber = row[mappings.payment.docNumber];
                    const amount = parseFloat(row[mappings.payment.amount]) || 0;
                    
                    if (docNumber) {
                        const key = normalizeOrderNumber(docNumber);
                        if (key) {
                            paymentOrderNumbers.push(key);
                            if (!indexes.payment[key]) {
                                indexes.payment[key] = 0;
                            }
                            indexes.payment[key] += amount;
                        }
                    }
                });
                
                // æ£€æµ‹æ”¶æ¬¾å•ä¸­çš„ç›¸ä¼¼è®¢å•å·
                const similarPayments = detectSimilarOrderNumbers([...new Set(paymentOrderNumbers)]);
                if (similarPayments.length > 0) {
                    console.warn('æ”¶æ¬¾å•ä¸­å‘ç°ç›¸ä¼¼è®¢å•å·:', similarPayments);
                    matchDiagnostics.similarOrderNumbers.push(...similarPayments.map(s => ({
                        source: 'æ”¶æ¬¾å•',
                        ...s
                    })));
                }
            }
            
            // å¸¦å•è´¹ç´¢å¼•ï¼ˆæŒ‰å•æ®ç¼–å·ï¼‰
            if (mappings.commission && dataStore.commission.data) {
                indexes.commission = {};
                const docNumberColIndex = mappings.commission.docNumber;
                if (docNumberColIndex !== undefined) {
                    dataStore.commission.data.forEach(row => {
                        const docNumber = row[docNumberColIndex];
                        if (docNumber) {
                            const key = normalizeOrderNumber(docNumber);
                            if (key) {
                                indexes.commission[key] = {};
                                fieldConfigs.commission.fields.forEach(field => {
                                    const colIndex = mappings.commission[field.key];
                                    if (colIndex !== undefined) {
                                        let value = row[colIndex];
                                        // å¯¹æŠ˜æ‰£å­—æ®µè¿›è¡Œè§„èŒƒåŒ–å¤„ç†
                                        if (field.key === 'actualDiscount') {
                                            value = normalizePercentage(value);
                                        }
                                        indexes.commission[key][field.key] = value;
                                    }
                                });
                            }
                        }
                    });
                }
            }
            
            // æ”¿ç­–è¡¨ç´¢å¼•ï¼ˆæ´»åŠ¨é™¤å¤–ï¼Œæ´»åŠ¨éœ€è¦æ ¹æ®æ—¥æœŸåŠ¨æ€åŒ¹é…ï¼‰
            buildPolicyIndex('policySpecialMachine', 'specialMachine', mappings, indexes);
            buildPolicyIndex('policyChanet', 'chanet', mappings, indexes);
            buildPolicyIndex('policyBoiler', 'boiler', mappings, indexes);
            buildPolicyIndex('policyPriceTable', 'priceTable', mappings, indexes);
            
            // æ´»åŠ¨å­è¡¨çš„ç´¢å¼•æ„å»ºï¼ˆæ”¯æŒå¤šä¸ªæ—¶é—´æ®µï¼‰
            if (mappings.policyActivity && Array.isArray(mappings.policyActivity)) {
                indexes.policyActivity = [];
                
                dataStore.policy.sheets.activity.forEach((activitySheet, index) => {
                    const mapping = mappings.policyActivity[index];
                    if (mapping) {
                        const activityIndex = {};
                        const config = fieldConfigs.policyActivity;
                        const data = activitySheet.data;
                        const headers = activitySheet.headers;
                        
                        // éœ€è¦è§„èŒƒåŒ–çš„æŠ˜æ‰£ç‡å­—æ®µ
                        const percentageFields = ['activityDiscount', 'boilerDiscount', 'minDiscount'];
                        
                        // æ‰¾åˆ°åŒ¹é…é”®åˆ—ï¼ˆæœºå‹åˆ—ï¼‰
                        const matchColIndex = headers.indexOf(config.matchKey);
                        
                        if (matchColIndex !== -1) {
                            data.forEach(row => {
                                const matchValue = row[matchColIndex];
                                if (matchValue) {
                                    const key = matchValue.toString().trim();
                                    activityIndex[key] = {};
                                    config.fields.forEach(field => {
                                        const colIndex = mapping[field.key];
                                        if (colIndex !== undefined) {
                                            let value = row[colIndex];
                                            // å¯¹æŠ˜æ‰£ç‡å­—æ®µè¿›è¡Œè§„èŒƒåŒ–å¤„ç†
                                            if (percentageFields.includes(field.key)) {
                                                value = normalizePercentage(value);
                                            }
                                            activityIndex[key][field.key] = value;
                                        }
                                    });
                                }
                            });
                        }
                        
                        indexes.policyActivity.push({
                            index: activityIndex,
                            startDate: activitySheet.startDate,
                            endDate: activitySheet.endDate,
                            sheetName: activitySheet.sheetName
                        });
                    } else {
                        indexes.policyActivity.push(null);
                    }
                });
            }
            
            return indexes;
        }

        function buildPolicyIndex(configKey, storeKey, mappings, indexes) {
            if (mappings[configKey] && dataStore.policy.sheets[storeKey].data) {
                indexes[configKey] = {};
                const config = fieldConfigs[configKey];
                const data = dataStore.policy.sheets[storeKey].data;
                const headers = dataStore.policy.sheets[storeKey].headers;
                
                // éœ€è¦è§„èŒƒåŒ–çš„æŠ˜æ‰£ç‡å­—æ®µ
                const percentageFields = ['activityDiscount', 'boilerDiscount', 'minDiscount'];
                
                // æ‰¾åˆ°åŒ¹é…é”®åˆ—ï¼ˆæœºå‹åˆ—ï¼‰
                const matchColIndex = headers.indexOf(config.matchKey);
                
                if (matchColIndex !== -1) {
                    data.forEach(row => {
                        const matchValue = row[matchColIndex];
                        if (matchValue) {
                            const key = matchValue.toString().trim();
                            indexes[configKey][key] = {};
                            config.fields.forEach(field => {
                                const colIndex = mappings[configKey][field.key];
                                if (colIndex !== undefined) {
                                    let value = row[colIndex];
                                    // å¯¹æŠ˜æ‰£ç‡å­—æ®µè¿›è¡Œè§„èŒƒåŒ–å¤„ç†
                                    if (percentageFields.includes(field.key)) {
                                        value = normalizePercentage(value);
                                    }
                                    indexes[configKey][key][field.key] = value;
                                }
                            });
                        }
                    });
                }
            }
        }

        function findModelColumn(headers) {
            const modelKeywords = ['è§„æ ¼å‹å·', 'æœºå‹', 'å‹å·', 'è§„æ ¼'];
            for (let i = 0; i < headers.length; i++) {
                const header = headers[i] ? headers[i].toString().trim() : '';
                if (modelKeywords.some(keyword => header.includes(keyword))) {
                    return i;
                }
            }
            return -1;
        }

        function identifyGuoBu(matchResult) {
            // ç¬¬ä¸€æ­¥ï¼šè¯†åˆ«é€€è´§è®¢å•ï¼ˆä¼˜å…ˆçº§é«˜ï¼‰
            // æŒ‰ (ç”¨æˆ·å§“å + è§„æ ¼å‹å·) åˆ†ç»„
            const returnGroupMap = {};
            
            matchResult.forEach((record, index) => {
                const userName = record['ç”¨æˆ·å§“å'] || '';
                const model = record['è§„æ ¼å‹å·'] || '';
                const key = `${userName}|${model}`;
                
                if (!returnGroupMap[key]) {
                    returnGroupMap[key] = [];
                }
                returnGroupMap[key].push(index);
            });
            
            // æ ‡è®°é€€è´§ï¼šä¸€æ­£ä¸€è´Ÿé…å¯¹æ ‡è®°ä¸ºé€€è´§
            const returnIndexes = new Set();
            Object.values(returnGroupMap).forEach(indexes => {
                // åˆ†ç¦»æ­£æ•°å’Œè´Ÿæ•°è®¢å•
                const positiveIndexes = [];
                const negativeIndexes = [];
                
                indexes.forEach(idx => {
                    const quantity = parseFloat(matchResult[idx]['é”€å”®æ•°é‡']) || 0;
                    if (quantity > 0) {
                        positiveIndexes.push(idx);
                    } else if (quantity < 0) {
                        negativeIndexes.push(idx);
                    }
                });
                
                // ä¸€æ­£ä¸€è´Ÿé…å¯¹æ ‡è®°ä¸ºé€€è´§
                const pairCount = Math.min(positiveIndexes.length, negativeIndexes.length);
                for (let i = 0; i < pairCount; i++) {
                    matchResult[positiveIndexes[i]]['è®¢å•ç±»å‹'] = 'é€€è´§';
                    matchResult[negativeIndexes[i]]['è®¢å•ç±»å‹'] = 'é€€è´§';
                    returnIndexes.add(positiveIndexes[i]);
                    returnIndexes.add(negativeIndexes[i]);
                }
            });
            
            // ç¬¬äºŒæ­¥ï¼šåœ¨éé€€è´§è®¢å•ä¸­è¯†åˆ«å›½è¡¥
            // æŒ‰ (æ—¥æœŸ + ç”¨æˆ·å§“å) åˆ†ç»„ç»Ÿè®¡
            const groupMap = {};
            
            matchResult.forEach((record, index) => {
                // è·³è¿‡å·²æ ‡è®°ä¸ºé€€è´§çš„è®¢å•
                if (returnIndexes.has(index)) return;
                
                const date = record['æ—¥æœŸ'] || '';
                const userName = record['ç”¨æˆ·å§“å'] || '';
                const key = `${date}|${userName}`;
                
                if (!groupMap[key]) {
                    groupMap[key] = [];
                }
                groupMap[key].push(index);
            });
            
            // æ ‡è®°å›½è¡¥ï¼šåŒä¸€å¤©å†…åŒä¸€ä¸ªäººæ°å¥½æœ‰2ç¬”è®¢å•åˆ™æ ‡è®°ä¸ºå›½è¡¥
            Object.values(groupMap).forEach(indexes => {
                if (indexes.length === 2) {
                    indexes.forEach(idx => {
                        matchResult[idx]['è®¢å•ç±»å‹'] = 'å›½è¡¥';
                    });
                } else {
                    indexes.forEach(idx => {
                        matchResult[idx]['è®¢å•ç±»å‹'] = 'éå›½è¡¥';
                    });
                }
            });
            
            // ç»Ÿè®¡
            const returnCount = matchResult.filter(r => r['è®¢å•ç±»å‹'] === 'é€€è´§').length;
            const guobuCount = matchResult.filter(r => r['è®¢å•ç±»å‹'] === 'å›½è¡¥').length;
            const nonGuobuCount = matchResult.filter(r => r['è®¢å•ç±»å‹'] === 'éå›½è¡¥').length;
            
            return { returnCount, guobuCount, nonGuobuCount };
        }

        function displayResult(stats) {
            const total = matchResult.length;
            
            // æ„å»ºç»Ÿè®¡ä¿¡æ¯
            const statsContainer = document.getElementById('resultStats');
            statsContainer.innerHTML = '';
            
            // æ·»åŠ é—¨åº—è¿‡æ»¤æç¤º
            if (filterStats.originalCount > 0) {
                const filterInfo = document.createElement('div');
                filterInfo.style.cssText = `
                    grid-column: 1 / -1;
                    background: #eef2ff;
                    border: 2px solid #c7d2fe;
                    border-radius: 8px;
                    padding: 12px 16px;
                    margin-bottom: 12px;
                    font-size: 13px;
                    color: #4338ca;
                `;
                filterInfo.innerHTML = `
                    <strong>ğŸª é—¨åº—ç­›é€‰ï¼š</strong>
                    åŸå§‹æ•°æ® <strong>${filterStats.originalCount}</strong> æ¡ï¼Œ
                    å·²è¿‡æ»¤ä¿ç•™ <strong>${filterStats.filteredCount}</strong> æ¡
                    ${filterStats.removedCount > 0 ? `ï¼ˆè¿‡æ»¤æ‰ <strong>${filterStats.removedCount}</strong> æ¡éæŒ‡å®šé—¨åº—æ•°æ®ï¼‰` : ''}
                    <br>
                    <small style="color: #6366f1;">ä»…ä¿ç•™ä»¥ä¸‹é—¨åº—ï¼š${storeWhitelist.join('ã€')}</small>
                `;
                statsContainer.appendChild(filterInfo);
            }
            
            const statItems = [
                { label: 'æ€»è®°å½•æ•°', value: total, color: '#667eea' },
                { label: 'é€€è´§è®¢å•', value: stats.return || 0, color: '#e53e3e' },
                { label: 'å›½è¡¥è®¢å•', value: stats.guobu || 0, color: '#f6ad55' },
                { label: 'éå›½è¡¥è®¢å•', value: stats.nonGuobu || 0, color: '#a0aec0' },
                { label: 'æ”¶æ¬¾åŒ¹é…', value: stats.payment, color: '#48bb78' },
                { label: 'å¸¦å•è´¹åŒ¹é…', value: stats.commission, color: '#4299e1' },
                { label: 'ç‰¹ä»·æœºåŒ¹é…', value: stats.specialMachine, color: '#ed8936' },
                { label: 'ä½³å°¼ç‰¹åŒ¹é…', value: stats.chanet, color: '#9f7aea' },
                { label: 'å£æŒ‚ç‚‰åŒ¹é…', value: stats.boiler, color: '#f56565' },
                { label: 'é”€å”®æ”¿ç­–åŒ¹é…', value: stats.activity, color: '#38b2ac' },
                { label: 'æ ‡ä»·è¡¨åŒ¹é…', value: stats.priceTable, color: '#ed64a6' }
            ];

            statItems.forEach(item => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.style.borderLeftColor = item.color;
                card.innerHTML = `
                    <div class="stat-label">${item.label}</div>
                    <div class="stat-value" style="color: ${item.color}">${item.value}</div>
                `;
                statsContainer.appendChild(card);
            });

            // æ˜¾ç¤ºè¯Šæ–­ä¿¡æ¯
            displayDiagnostics();

            // æ„å»ºè¡¨æ ¼
            const thead = document.getElementById('resultTableHeader');
            const tbody = document.getElementById('resultTableBody');
            
            thead.innerHTML = '';
            tbody.innerHTML = '';

            if (matchResult.length > 0) {
                // è¡¨å¤´
                const headerRow = document.createElement('tr');
                Object.keys(matchResult[0]).forEach(key => {
                    const th = document.createElement('th');
                    th.textContent = key;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);

                // æ•°æ®è¡Œï¼ˆé™åˆ¶æ˜¾ç¤ºå‰1000è¡Œä»¥æé«˜æ€§èƒ½ï¼‰
                const displayLimit = Math.min(matchResult.length, 1000);
                for (let i = 0; i < displayLimit; i++) {
                    const record = matchResult[i];
                    const tr = document.createElement('tr');
                    Object.values(record).forEach(value => {
                        const td = document.createElement('td');
                        td.textContent = value !== undefined && value !== null ? value : '';
                        tr.appendChild(td);
                    });
                    tbody.appendChild(tr);
                }

                if (matchResult.length > displayLimit) {
                    const tr = document.createElement('tr');
                    const td = document.createElement('td');
                    td.colSpan = Object.keys(matchResult[0]).length;
                    td.style.textAlign = 'center';
                    td.style.color = '#718096';
                    td.style.fontStyle = 'italic';
                    td.textContent = `... è¿˜æœ‰ ${matchResult.length - displayLimit} æ¡è®°å½•æœªæ˜¾ç¤ºï¼Œè¯·å¯¼å‡ºæŸ¥çœ‹å®Œæ•´æ•°æ®`;
                    tr.appendChild(td);
                    tbody.appendChild(tr);
                }
            }

            document.getElementById('resultArea').style.display = 'block';
            document.getElementById('resultArea').scrollIntoView({ behavior: 'smooth' });
        }

        function displayDiagnostics() {
            let diagnosticsHtml = '';
            
            // æ˜¾ç¤ºç›¸ä¼¼è®¢å•å·è­¦å‘Š
            if (matchDiagnostics.similarOrderNumbers.length > 0) {
                diagnosticsHtml += '<div class="alert alert-warning">';
                diagnosticsHtml += '<strong>âš ï¸ è­¦å‘Šï¼šå‘ç°ç›¸ä¼¼è®¢å•å·</strong><br>';
                diagnosticsHtml += 'ä»¥ä¸‹è®¢å•å·éå¸¸ç›¸ä¼¼ï¼Œå¯èƒ½å¯¼è‡´åŒ¹é…æ··æ·†ã€‚è¯·ç¡®è®¤æ•°æ®æ˜¯å¦æ­£ç¡®ï¼š<br><br>';
                
                const groupedBySimilarity = {};
                matchDiagnostics.similarOrderNumbers.forEach(item => {
                    const key = `${item.base}-${item.extended}`;
                    if (!groupedBySimilarity[key]) {
                        groupedBySimilarity[key] = [];
                    }
                    groupedBySimilarity[key].push(item.source);
                });
                
                Object.keys(groupedBySimilarity).forEach(key => {
                    const [base, extended] = key.split('-').slice(0, 2);
                    const sources = [...new Set(groupedBySimilarity[key])];
                    diagnosticsHtml += `ğŸ“‹ <code>${base}</code> å’Œ <code>${extended}</code> ï¼ˆæ¥æºï¼š${sources.join('ã€')}ï¼‰<br>`;
                });
                
                diagnosticsHtml += '</div>';
            }
            
            // æ˜¾ç¤ºæœªåŒ¹é…è®¢å•
            if (matchDiagnostics.unmatchedOrders.length > 0) {
                diagnosticsHtml += '<div class="alert alert-danger">';
                diagnosticsHtml += `<strong>âŒ æœªæ‰¾åˆ°å›æ¬¾çš„è®¢å•ï¼š${matchDiagnostics.unmatchedOrders.length} æ¡</strong><br>`;
                diagnosticsHtml += 'ä»¥ä¸‹è®¢å•åœ¨æ”¶æ¬¾å•ä¸­æœªæ‰¾åˆ°åŒ¹é…ï¼ˆå›æ¬¾é‡‘é¢å·²è®¾ä¸º0ï¼‰ï¼š<br><br>';
                
                const displayLimit = Math.min(matchDiagnostics.unmatchedOrders.length, 10);
                for (let i = 0; i < displayLimit; i++) {
                    const order = matchDiagnostics.unmatchedOrders[i];
                    diagnosticsHtml += `ğŸ“„ è®¢å•å·ï¼š<code>${order.orderNumberRaw || order.orderNumber}</code>`;
                    if (order.userName) diagnosticsHtml += ` | å®¢æˆ·ï¼š${order.userName}`;
                    if (order.model) diagnosticsHtml += ` | å‹å·ï¼š${order.model}`;
                    if (order.totalAmount) diagnosticsHtml += ` | é‡‘é¢ï¼šÂ¥${order.totalAmount}`;
                    diagnosticsHtml += '<br>';
                }
                
                if (matchDiagnostics.unmatchedOrders.length > displayLimit) {
                    diagnosticsHtml += `<i>... è¿˜æœ‰ ${matchDiagnostics.unmatchedOrders.length - displayLimit} æ¡æœªæ˜¾ç¤º</i><br>`;
                }
                
                diagnosticsHtml += '</div>';
            }
            
            // æ˜¾ç¤ºæœªåŒ¹é…æ”¶æ¬¾
            if (matchDiagnostics.unmatchedPayments.length > 0) {
                diagnosticsHtml += '<div class="alert alert-danger">';
                diagnosticsHtml += `<strong>âŒ æœªæ‰¾åˆ°è®¢å•çš„æ”¶æ¬¾ï¼š${matchDiagnostics.unmatchedPayments.length} æ¡</strong><br>`;
                diagnosticsHtml += 'ä»¥ä¸‹æ”¶æ¬¾è®°å½•åœ¨é”€å”®è®¢å•ä¸­æœªæ‰¾åˆ°åŒ¹é…ï¼š<br><br>';
                
                const displayLimit = Math.min(matchDiagnostics.unmatchedPayments.length, 10);
                for (let i = 0; i < displayLimit; i++) {
                    const payment = matchDiagnostics.unmatchedPayments[i];
                    diagnosticsHtml += `ğŸ’° è®¢å•å·ï¼š<code>${payment.orderNumber}</code> | é‡‘é¢ï¼šÂ¥${payment.paymentAmount}<br>`;
                }
                
                if (matchDiagnostics.unmatchedPayments.length > displayLimit) {
                    diagnosticsHtml += `<i>... è¿˜æœ‰ ${matchDiagnostics.unmatchedPayments.length - displayLimit} æ¡æœªæ˜¾ç¤º</i><br>`;
                }
                
                diagnosticsHtml += '</div>';
            }
            
            // æˆåŠŸåŒ¹é…æç¤º
            if (matchDiagnostics.similarOrderNumbers.length === 0 && 
                matchDiagnostics.unmatchedOrders.length === 0 && 
                matchDiagnostics.unmatchedPayments.length === 0) {
                diagnosticsHtml += '<div class="alert alert-info">';
                diagnosticsHtml += '<strong>âœ… æ•°æ®è´¨é‡è‰¯å¥½</strong><br>';
                diagnosticsHtml += 'æœªå‘ç°è®¢å•å·å†²çªæˆ–æœªåŒ¹é…çš„è®°å½•ã€‚';
                diagnosticsHtml += '</div>';
            }
            
            // æ’å…¥è¯Šæ–­ä¿¡æ¯åˆ°ç»“æœåŒºåŸŸ
            const resultStats = document.getElementById('resultStats');
            const existingDiagnostics = document.getElementById('diagnosticsContainer');
            if (existingDiagnostics) {
                existingDiagnostics.remove();
            }
            
            if (diagnosticsHtml) {
                const diagnosticsContainer = document.createElement('div');
                diagnosticsContainer.id = 'diagnosticsContainer';
                diagnosticsContainer.innerHTML = diagnosticsHtml;
                resultStats.parentNode.insertBefore(diagnosticsContainer, resultStats.nextSibling);
            }
        }

        function exportUnmatchedData() {
            if (matchDiagnostics.unmatchedOrders.length === 0 && 
                matchDiagnostics.unmatchedPayments.length === 0) {
                alert('æ²¡æœ‰æœªåŒ¹é…çš„æ•°æ®éœ€è¦å¯¼å‡ºï¼');
                return;
            }

            const wb = XLSX.utils.book_new();

            // å¯¼å‡ºæœªåŒ¹é…è®¢å•
            if (matchDiagnostics.unmatchedOrders.length > 0) {
                const ws1 = XLSX.utils.json_to_sheet(matchDiagnostics.unmatchedOrders.map(order => ({
                    'è®¢å•å·ï¼ˆåŸå§‹ï¼‰': order.orderNumberRaw,
                    'è®¢å•å·ï¼ˆè§„èŒƒåŒ–ï¼‰': order.orderNumber,
                    'ç”¨æˆ·å§“å': order.userName,
                    'è§„æ ¼å‹å·': order.model,
                    'ä»·ç¨åˆè®¡': order.totalAmount
                })));
                XLSX.utils.book_append_sheet(wb, ws1, 'æœªåŒ¹é…è®¢å•');
            }

            // å¯¼å‡ºæœªåŒ¹é…æ”¶æ¬¾
            if (matchDiagnostics.unmatchedPayments.length > 0) {
                const ws2 = XLSX.utils.json_to_sheet(matchDiagnostics.unmatchedPayments.map(payment => ({
                    'è®¢å•å·': payment.orderNumber,
                    'æ”¶æ¬¾é‡‘é¢': payment.paymentAmount
                })));
                XLSX.utils.book_append_sheet(wb, ws2, 'æœªåŒ¹é…æ”¶æ¬¾');
            }

            // å¯¼å‡ºç›¸ä¼¼è®¢å•å·
            if (matchDiagnostics.similarOrderNumbers.length > 0) {
                const ws3 = XLSX.utils.json_to_sheet(matchDiagnostics.similarOrderNumbers.map(item => ({
                    'æ¥æº': item.source,
                    'åŸºç¡€è®¢å•å·': item.base,
                    'æ‰©å±•è®¢å•å·': item.extended,
                    'åç¼€': item.suffix
                })));
                XLSX.utils.book_append_sheet(wb, ws3, 'ç›¸ä¼¼è®¢å•å·');
            }

            // ç”Ÿæˆæ–‡ä»¶å
            const date = new Date();
            const filename = `æœªåŒ¹é…æ•°æ®è¯Šæ–­_${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}_${date.getHours().toString().padStart(2,'0')}${date.getMinutes().toString().padStart(2,'0')}.xlsx`;

            // ä¸‹è½½
            XLSX.writeFile(wb, filename);
        }

        function exportResult() {
            if (matchResult.length === 0) {
                alert('æ²¡æœ‰å¯å¯¼å‡ºçš„æ•°æ®ï¼');
                return;
            }

            // å¯¼å‡ºå‰å¯¹æ‰€æœ‰æŠ˜æ‰£ç‡å­—æ®µè¿›è¡ŒäºŒæ¬¡è§„èŒƒåŒ–
            const discountFields = ['é”€å”®æ”¿ç­–æŠ˜æ‰£ç‡', 'å£æŒ‚ç‚‰é”€å”®æŠ˜æ‰£', 'ç‰¹ä»·æœºå…¬å¸æœ€ä½æŠ˜æ‰£', 'å–å‡ºçš„å®é™…æŠ˜æ‰£'];
            const normalizedResult = matchResult.map(record => {
                const newRecord = { ...record };
                discountFields.forEach(field => {
                    if (field in newRecord) {
                        newRecord[field] = normalizePercentage(newRecord[field]);
                    }
                });
                return newRecord;
            });

            // è½¬æ¢ä¸ºå·¥ä½œè¡¨
            const ws = XLSX.utils.json_to_sheet(normalizedResult);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'åŒ¹é…ç»“æœ');

            // ç”Ÿæˆæ–‡ä»¶å
            const date = new Date();
            const filename = `åŒ¹é…ç»“æœ_${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}_${date.getHours().toString().padStart(2,'0')}${date.getMinutes().toString().padStart(2,'0')}.xlsx`;

            // ä¸‹è½½
            XLSX.writeFile(wb, filename);
        }
    </script>
</body>
</html>

