<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>智能表格匹配工具（性能优化版）</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<script>
/*
说明（本版本较上一版的核心新增）：
1. 使用 Web Worker 进行文件解析与匹配，避免主线程卡死“此页面没有响应”
2. 解析分为“预览解析 (只读前 PREVIEW_LIMIT 行)” 与 “完整匹配解析” 两阶段
3. 预览表格采用行虚拟化（仅渲染可视区的行），支持 10万+ 行不卡界面
4. 匹配过程分块 / 时间切片，实时进度反馈
5. 大数据集导出：行*列 > 阈值时自动回退为 CSV 导出，减少内存占用
6. 增加超大文件提示、内存估算、可取消的异步任务
7. 主线程不再保存所有原始数据（仅存预览 + 选择信息），完整数据驻留在 Worker 内
*/
</script>
<style>
*{box-sizing:border-box}body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif;background:#f3f5f9;color:#222}
header{background:linear-gradient(120deg,#4caf50,#2196f3);padding:18px 22px;color:#fff}
h1{font-size:1.4rem;margin:0}
small.muted{opacity:.8}
.container{max-width:1400px;margin:16px auto;padding:0 16px}
.panel{background:#fff;border-radius:14px;padding:20px 22px;margin-bottom:22px;box-shadow:0 4px 18px -6px rgba(0,0,0,.08)}
.panel h2{margin:0 0 12px;font-size:1.1rem;display:flex;align-items:center;gap:6px}
.flex{display:flex;gap:16px;flex-wrap:wrap}
.upload-box{flex:1;min-width:260px;border:2px dashed #cfd8dc;border-radius:10px;padding:26px;text-align:center;cursor:pointer;position:relative;transition:.25s;background:#fafbfc}
.upload-box:hover{border-color:#4caf50;background:#f1faf2}
.upload-box.active{border-color:#4caf50;background:#e8f5e9}
.upload-box input{display:none}
.badge{display:inline-block;padding:2px 8px;border-radius:14px;font-size:12px;background:#e3f2fd;color:#1976d2;margin-left:4px}
.note{font-size:12px;color:#666;line-height:1.5;margin-top:6px}
.sheet-list{display:grid;grid-template-columns:repeat(auto-fill,minmax(170px,1fr));gap:8px;margin-top:8px}
.sheet-item{border:1px solid #d0d7de;border-radius:8px;padding:8px 10px;font-size:13px;display:flex;flex-direction:column;gap:2px;cursor:pointer;background:#fff;transition:.2s}
.sheet-item:hover{border-color:#4caf50;background:#f4fbf5}
.sheet-item.active{border-color:#4caf50;background:#e8f5e9}
.sheet-item .meta{font-size:11px;color:#555;display:flex;gap:6px;flex-wrap:wrap}
.hidden{display:none !important}
.btn{border:none;background:#4caf50;color:#fff;padding:10px 20px;font-size:14px;border-radius:8px;cursor:pointer;transition:.25s;display:inline-flex;align-items:center;gap:6px}
.btn:hover{background:#43a047}
.btn:disabled{background:#bdbdbd;cursor:not-allowed}
.btn.secondary{background:#607d8b}.btn.secondary:hover{background:#546e7a}
.btn.danger{background:#f44336}.btn.danger:hover{background:#e53935}
.btn.light{background:#eceff1;color:#333}.btn.light:hover{background:#e0e3e6}
.inline{display:inline-flex;gap:8px;flex-wrap:wrap}
.form-row{display:flex;gap:16px;flex-wrap:wrap;margin-top:12px}
.form-row>div{flex:1;min-width:200px}
select,input[type=text]{width:100%;padding:8px 10px;font-size:14px;border:1px solid #cfd8dc;border-radius:6px;background:#fff}
.field-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:10px;margin-top:12px;max-height:260px;overflow:auto;border:1px solid #eee;padding:8px;border-radius:8px;background:#fff}
.field-item{display:flex;align-items:center;gap:6px;font-size:13px}
.progress-wrap{margin:14px 0}
.progress-bar{height:18px;background:#e0e0e0;border-radius:10px;overflow:hidden;position:relative}
.progress-fill{height:100%;width:0;background:linear-gradient(90deg,#4caf50,#2196f3);transition:width .35s}
.progress-text{position:absolute;left:50%;top:0;transform:translateX(-50%);font-size:11px;line-height:18px;color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.4)}
.stat-cards{display:flex;flex-wrap:wrap;gap:14px;margin-top:12px}
.stat{flex:1;min-width:140px;background:#fff;border-radius:12px;padding:14px 12px;box-shadow:0 2px 10px rgba(0,0,0,.06);text-align:center}
.stat .num{font-size:1.6rem;font-weight:600;color:#4caf50}
.log-box{background:#111;color:#c8e6c9;font-family:ui-monospace,monospace;font-size:11px;padding:8px 10px;border-radius:8px;max-height:150px;overflow:auto;line-height:1.45;margin-top:10px;white-space:pre-wrap}
.warn{background:#fff3cd;border:1px solid #ffe58f;padding:10px 14px;border-radius:8px;font-size:13px;color:#795548;margin-top:10px}
.danger-box{background:#ffebee;border:1px solid #ffcdd2;color:#c62828;padding:10px 14px;font-size:13px;border-radius:8px;margin-top:10px}
.flex-between{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
.virtual-table-container{position:relative;border:1px solid #d0d7de;border-radius:10px;background:#fff;margin-top:14px;height:360px;overflow:auto;font-size:12px}
.virtual-table{border-collapse:collapse;min-width:100%}
.virtual-table th,.virtual-table td{border-bottom:1px solid #eee;padding:6px 8px;text-align:left;max-width:260px;word-break:break-all}
.virtual-table thead th{position:sticky;top:0;background:#f5f7fa;z-index:2}
.shadow-fade{position:absolute;left:0;right:0;height:18px;pointer-events:none}
.shadow-top{top:0;background:linear-gradient(#ffffffcc,#ffffff00)}
.shadow-bottom{bottom:0;background:linear-gradient(#ffffff00,#ffffffcc)}
.small{font-size:12px;opacity:.8}
.label{font-size:12px;color:#555;margin-bottom:4px;display:block}
.toggle-group{display:flex;gap:8px;flex-wrap:wrap}
.tag{display:inline-block;background:#eee;color:#555;font-size:10px;padding:2px 6px;border-radius:4px;margin-left:6px}
.pill{background:#4caf50;color:#fff;font-size:11px;padding:2px 8px;border-radius:20px;margin-left:6px}
.link-btn{background:none;border:none;color:#1976d2;cursor:pointer;font-size:12px;padding:0}
footer{padding:30px 0;font-size:12px;text-align:center;color:#888}
.loading-inline{display:inline-flex;align-items:center;gap:6px}
.spinner{width:16px;height:16px;border:2px solid #cfd8dc;border-top-color:#4caf50;border-radius:50%;animation:spin 1s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
</style>
</head>
<body>
<header>
<h1>🔗 智能表格匹配工具（多工作表增强版 · 性能优化）</h1>
<small class="muted">Web Worker + 虚拟滚动 + 分块匹配，解决“页面无响应”问题</small>
</header>
<div class="container">

<!-- 步骤 1：上传 -->
<div class="panel" id="panel-upload">
  <h2>📁 步骤1 上传文件</h2>
  <div class="flex">
    <label class="upload-box" id="u1">
      <strong>主表文件</strong><br><small id="u1-info">点击选择 (.xlsx/.xls/.csv)</small>
      <input type="file" id="file1" accept=".xlsx,.xls,.csv">
    </label>
    <label class="upload-box" id="u2">
      <strong>匹配表文件</strong><br><small id="u2-info">点击选择 (.xlsx/.xls/.csv)</small>
      <input type="file" id="file2" accept=".xlsx,.xls,.csv">
    </label>
  </div>
  <div class="note">
    解析策略：先快速读取前 200 行用于预览，真正匹配时再全量解析，避免提前加载全部数据。<br>
    如果文件非常大（> 20MB 或 > 10 万行）会提示使用 CSV + 分块处理 / 或拆分为多文件。
  </div>
  <div id="bigFileTips" class="warn hidden"></div>
  <div id="sheetArea1" class="hidden">
    <h3>主表工作表选择</h3>
    <div class="sheet-list" id="sheetList1"></div>
  </div>
  <div id="sheetArea2" class="hidden">
    <h3>匹配表工作表选择</h3>
    <div class="sheet-list" id="sheetList2"></div>
  </div>
  <div id="previewArea" class="flex">
    <div style="flex:1;min-width:320px" class="hidden" id="previewWrap1">
      <div class="flex-between">
        <h3 style="margin:10px 0 6px;font-size:14px">主表预览 <span id="pvMeta1" class="small"></span></h3>
        <button class="link-btn" data-preview-refresh="1">重新清洗</button>
      </div>
      <div id="tablePreview1" class="virtual-table-container"></div>
    </div>
    <div style="flex:1;min-width:320px" class="hidden" id="previewWrap2">
      <div class="flex-between">
        <h3 style="margin:10px 0 6px;font-size:14px">匹配表预览 <span id="pvMeta2" class="small"></span></h3>
        <button class="link-btn" data-preview-refresh="2">重新清洗</button>
      </div>
      <div id="tablePreview2" class="virtual-table-container"></div>
    </div>
  </div>
  <div id="uploadLog" class="log-box hidden"></div>
</div>

<!-- 步骤 2：配置 -->
<div class="panel hidden" id="panel-config">
  <h2>⚙️ 步骤2 配置匹配规则</h2>
  <div class="warn" id="configHint">
    已选工作表：<strong id="selSheet1">-</strong> / <strong id="selSheet2">-</strong><br>
    若字段识别不正确，可回到上一步重新选择或换用 CSV。
  </div>
  <div class="form-row">
    <div>
      <label class="label">主表匹配字段</label>
      <select id="key1"></select>
    </div>
    <div>
      <label class="label">匹配表匹配字段</label>
      <select id="key2"></select>
    </div>
    <div>
      <label class="label">匹配模式</label>
      <select id="matchMode">
        <option value="exact">精确</option>
        <option value="fuzzy">模糊(去首尾空格/忽略大小写)</option>
        <option value="smart">智能(再去内部空白)</option>
      </select>
    </div>
    <div>
      <label class="label">未匹配填充值</label>
      <input type="text" id="unmatchedFill" placeholder="默认空字符串">
    </div>
  </div>
  <div style="margin-top:16px">
    <strong>选择要追加的字段 <span class="tag">来自匹配表</span></strong>
    <div class="inline" style="margin-top:6px">
      <button class="btn light" id="btnAll">全选</button>
      <button class="btn light" id="btnNone">全不选</button>
      <button class="btn light" id="btnInvert">反选</button>
    </div>
    <div id="fieldGrid" class="field-grid"></div>
  </div>
  <div style="margin-top:20px" class="inline">
    <button class="btn" id="btnStartMatch">🔍 开始匹配</button>
    <button class="btn secondary" id="btnBack">⬅️ 返回上一步</button>
    <button class="btn danger hidden" id="btnCancelTask">⛔ 取消进行中任务</button>
  </div>
  <div id="matchLog" class="log-box hidden"></div>
</div>

<!-- 步骤 3：结果 -->
<div class="panel hidden" id="panel-result">
  <h2>📊 步骤3 匹配结果</h2>
  <div class="progress-wrap">
    <div class="progress-bar"><div class="progress-fill" id="progressFill"></div><div class="progress-text" id="progressText">0%</div></div>
    <div class="small" id="progressDetail"></div>
  </div>
  <div class="stat-cards">
    <div class="stat"><div class="num" id="statTotal">0</div><div>总行数</div></div>
    <div class="stat"><div class="num" id="statMatched">0</div><div>匹配成功</div></div>
    <div class="stat"><div class="num" id="statUnmatched">0</div><div>未匹配</div></div>
    <div class="stat"><div class="num" id="statRate">0%</div><div>匹配率</div></div>
  </div>
  <div class="warn" id="exportHint" style="margin-top:14px"></div>
  <div style="margin-top:18px" class="inline">
    <button class="btn" id="btnDownload">💾 下载结果</button>
    <button class="btn secondary" id="btnDownloadUnmatched">📤 导出未匹配</button>
    <button class="btn danger" id="btnResetAll">🔄 重新开始</button>
  </div>
  <h3 style="margin:24px 0 6px;font-size:14px">结果预览（前 150 行）</h3>
  <div id="resultPreview" class="virtual-table-container"></div>
  <div id="resultLog" class="log-box hidden"></div>
</div>

<footer>
  性能提示：超大文件请优先转换为 CSV；也可分批导入多次合并。当前版本支持十万级行浏览与匹配（视浏览器内存而定）。
</footer>
</div>

<script>
/* ------------------ 常量配置 ------------------- */
const PREVIEW_LIMIT = 200;              // 预览读取行（含表头）
const VIRTUAL_ROW_HEIGHT = 28;          // 估算单行高度（PX）
const BLOCK_MATCH_SIZE = 2000;          // 每批匹配行数（时间切片）
const LARGE_DATA_CELL_THRESHOLD = 5_000_000; // 行*列 超过则导出 CSV
const BIG_FILE_SIZE_WARN = 20 * 1024 * 1024;
let worker = null;
let fileBuffers = {1:null,2:null}; // ArrayBuffer
let selectedSheet = {1:null,2:null};
let previewMeta = {1:null,2:null};
let headers = {1:[],2:[]};
let fieldSelectionCache = [];
let currentTaskId = 0;
let resultMeta = null;
let lastResultPreview = null;
let exportedBlobInfo = null;

/* ------------------ 初始化 Worker ------------------- */
function createWorker(){
const code = `
self.importScripts('https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js');
const PREVIEW_LIMIT = ${PREVIEW_LIMIT};
function parseArrayBuffer(buf,isCSV,filename){
  if(isCSV){
    const decoder = new TextDecoder('utf-8');
    const text = decoder.decode(buf);
    return {wb:null,csvText:text};
  }else{
    const data = new Uint8Array(buf);
    const arr = [];
    for(let i=0;i<data.length;i++) arr[i] = String.fromCharCode(data[i]);
    const bstr = arr.join('');
    const wb = XLSX.read(bstr,{type:'binary',dense:true});
    return {wb,csvText:null};
  }
}
function aoaFromSheet(sheet){
  return XLSX.utils.sheet_to_json(sheet,{header:1,raw:false,blankrows:false});
}
function cleanAndDetectHeader(data){
  if(!data||!data.length) return [];
  let arr = data.map(r=>Array.isArray(r)?r:[r]);
  const isEmptyRow = r=>!r||r.every(c=> (c===undefined||c===null||(''+c).trim()===''));
  while(arr.length && isEmptyRow(arr[0])) arr.shift();
  while(arr.length && isEmptyRow(arr[arr.length-1])) arr.pop();
  const candidate = Math.min(6,arr.length);
  let bestI=0,bestScore=-1;
  for(let i=0;i<candidate;i++){
    const nonEmpty = arr[i].filter(c=> (c!==undefined && c!==null && (''+c).trim()!=='')).length;
    if(nonEmpty>bestScore){bestScore=nonEmpty;bestI=i;}
  }
  if(arr.length>=2){
    const f = arr[0].filter(c=> (c||'').toString().trim()!=='').length;
    const s = arr[1].filter(c=> (c||'').toString().trim()!=='').length;
    if(f<=1 && s>=Math.max(2,f+1)) bestI=1;
  }
  const header = (arr[bestI]||[]).map(c=>(c||'').toString().trim());
  arr = arr.slice(bestI+1).filter(r=>!isEmptyRow(r));
  let colCount = Math.max(header.length,...arr.map(r=>r.length));
  const colEmpty = [];
  for(let c=0;c<colCount;c++){
    let any=false;
    if(header[c] && header[c].toString().trim()!=='') any=true;
    for(let r=0;r<arr.length && !any;r++){
      const v = arr[r][c];
      if(v!==undefined && v!==null && (''+v).trim()!=='') any=true;
    }
    colEmpty[c]=!any;
  }
  while(colEmpty.length && colEmpty[0]){colEmpty.shift();header.shift();arr.forEach(r=>r.shift());}
  while(colEmpty.length && colEmpty[colEmpty.length-1]){colEmpty.pop();header.pop();arr.forEach(r=>r.pop());}
  const finalLen = header.length;
  const normalized = arr.map(r=>{
    const nr = new Array(finalLen);
    for(let i=0;i<finalLen;i++) nr[i] = (r[i]!==undefined && r[i]!==null)?(''+r[i]).trim():'';
    return nr;
  });
  const seen={};
  const uniqHeader = header.map((h,i)=>{
    const base = h || ('列'+(i+1));
    if(!seen[base]){seen[base]=1;return base;}
    const newName = base+'_'+seen[base];seen[base]++;return newName;
  });
  return [uniqHeader,...normalized];
}
function buildPreview(aoa){
  const cleaned = cleanAndDetectHeader(aoa);
  if(!cleaned.length) return {header:[],rows:[],rawRows:0,cleanRows:0};
  const header = cleaned[0];
  const rows = cleaned.slice(1,1+PREVIEW_LIMIT-1);
  return {header,rows,rawRows:aoa.length,cleanRows:cleaned.length-1};
}
function normalizeKey(key,mode){
  if(key===undefined||key===null) return '';
  let v=''+key;
  if(mode==='exact') return v;
  v = v.toLowerCase().trim();
  if(mode==='smart') v = v.replace(/\\s+/g,'');
  return v;
}
function toCSV(aoa){
  return aoa.map(r=> r.map(c=>{
    if(c==null) return '';
    const s=''+c;
    if(/[",\\n]/.test(s)) return '"'+s.replace(/"/g,'""')+'"';
    return s;
  }).join(',')).join('\\r\\n');
}
let storedFull = {
  // key: task-specific or (fileId|sheetName)
};
self.onmessage = async (e)=>{
  const {cmd,taskId} = e.data;
  try{
    if(cmd==='preview'){
      const {fileId,buffer,isCSV,filename} = e.data;
      const parsed = parseArrayBuffer(buffer,isCSV,filename);
      let sheetsMeta=[];
      if(isCSV){
        // CSV 当做单 sheet
        const lines = parsed.csvText.split(/\\r?\\n/).map(l=>l.split(','));
        const preview = buildPreview(lines);
          sheetsMeta.push({
            name:'Sheet1',
            header:preview.header,
            previewRows:preview.rows,
            rawRows:preview.rawRows,
            cleanRows:preview.cleanRows
          });
        storedFull[fileId]={buffer,isCSV,filename};
      }else{
        const wb = parsed.wb;
        storedFull[fileId]={buffer,isCSV:false,filename,sheetNames:wb.SheetNames};
        wb.SheetNames.forEach(sn=>{
          try{
            const sheet = wb.Sheets[sn];
            const aoa = aoaFromSheet(sheet);
            const preview = buildPreview(aoa);
            sheetsMeta.push({
              name:sn,
              header:preview.header,
              previewRows:preview.rows,
              rawRows:aoa.length,
              cleanRows:preview.cleanRows
            });
          }catch(err){
            sheetsMeta.push({name:sn,error:err.message});
          }
        });
      }
      postMessage({cmd:'preview-done',taskId,fileId,sheetsMeta});
    }
    else if(cmd==='refreshPreviewSheet'){
      const {fileId,sheetName} = e.data;
      const stored = storedFull[fileId];
      if(!stored) throw new Error('未找到文件缓存');
      if(stored.isCSV){
        const decoder = new TextDecoder('utf-8');
        const txt = new TextDecoder().decode(stored.buffer);
        const lines = txt.split(/\\r?\\n/).map(l=>l.split(','));
        const preview = buildPreview(lines);
        postMessage({cmd:'refreshPreview-done',taskId,fileId,sheetName:'Sheet1',header:preview.header,previewRows:preview.rows,rawRows:preview.rawRows,cleanRows:preview.cleanRows});
      }else{
        const data = new Uint8Array(stored.buffer);
        const arr=[];for(let i=0;i<data.length;i++) arr[i]=String.fromCharCode(data[i]);
        const wb = XLSX.read(arr.join(''),{type:'binary',dense:true});
        const sheet = wb.Sheets[sheetName];
        const aoa = aoaFromSheet(sheet);
        const preview = buildPreview(aoa);
        postMessage({cmd:'refreshPreview-done',taskId,fileId,sheetName,header:preview.header,previewRows:preview.rows,rawRows:aoa.length,cleanRows:preview.cleanRows});
      }
    }
    else if(cmd==='startMatch'){
      const {file1,file2,sheet1,sheet2,key1,key2,mode,fields,unmatchedFill} = e.data;
      // 重新全量解析
      function fullClean(fileId,sheet){
        const rec = storedFull[fileId];
          if(!rec) throw new Error('文件缓存不存在:'+fileId);
          if(rec.isCSV){
            const txt = new TextDecoder().decode(rec.buffer);
            const lines = txt.split(/\\r?\\n/).map(l=>l.split(','));
            return cleanAndDetectHeader(lines);
          }else{
            const u8 = new Uint8Array(rec.buffer);
            const arr=[];for(let i=0;i<u8.length;i++) arr[i]=String.fromCharCode(u8[i]);
            const wb = XLSX.read(arr.join(''),{type:'binary',dense:true});
            const target = wb.Sheets[sheet];
            if(!target) throw new Error('找不到工作表:'+sheet);
            const aoa = aoaFromSheet(target);
            return cleanAndDetectHeader(aoa);
          }
      }
      const t1 = fullClean(file1,sheet1);
      const t2 = fullClean(file2,sheet2);
      const h1 = t1[0]; const h2 = t2[0];
      const d1 = t1.slice(1);
      const d2 = t2.slice(1);
      // 建立索引
      const map = new Map();
      for(const r of d2){
        const k = normalizeKey(r[key2],mode);
        if(!map.has(k)) map.set(k,[]);
        map.get(k).push(r);
      }
      const newHeader = h1.concat(fields.map(i=>h2[i]));
      const total = d1.length;
      let matched=0;
      const previewOut = [newHeader];
      let outRowsCount=0;
      // 因为完整结果可能很大，不把全部行存在主线程；在 worker 中构建最终导出数据
      const exportAoa = [newHeader];
      const startTime = Date.now();
      for(let i=0;i<total;i++){
        if(i % ${BLOCK_MATCH_SIZE} === 0 && i>0){
          const pct = ((i/total)*100).toFixed(2);
          postMessage({cmd:'match-progress',taskId,progress:i,total,percent:pct,matched,elapsed:Date.now()-startTime});
        }
        const r1 = d1[i];
        const k = normalizeKey(r1[key1],mode);
          const base = r1.slice();
          if(map.has(k)){
            const mr = map.get(k)[0];
            for(const f of fields) base.push(mr[f] ?? '');
            matched++;
          }else{
            for(const _ of fields) base.push(unmatchedFill);
          }
        exportAoa.push(base);
        if(previewOut.length<151) previewOut.push(base); // 结果预览前 150 行
      }
      const unmatched = total - matched;
      const matchRate = total? (matched/total):0;
      // 判断导出方式
      const cellCount = exportAoa.length * newHeader.length;
      let exportType = 'xlsx';
      if(cellCount > ${LARGE_DATA_CELL_THRESHOLD}){
        exportType='csv';
      }
      // 生成导出 blob
      let blob;
      if(exportType==='xlsx'){
        const ws = XLSX.utils.aoa_to_sheet(exportAoa);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb,ws,'匹配结果');
        const wbout = XLSX.write(wb,{bookType:'xlsx',type:'array'});
        blob = new Blob([wbout],{type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
      }else{
        const csv = toCSV(exportAoa);
        blob = new Blob([csv],{type:'text/csv;charset=utf-8'});
      }
      const unmatchedAoa = [newHeader];
      const baseLen = h1.length;
      for(let i=1;i<exportAoa.length;i++){
        const row = exportAoa[i];
        let allEmpty=true;
        for(let c=baseLen;c<row.length;c++){
          if(row[c] && (''+row[c]).trim()!==''){allEmpty=false;break;}
        }
        if(allEmpty) unmatchedAoa.push(row);
      }
      let unmatchedBlob=null;
      if(unmatchedAoa.length>1){
        if(exportType==='xlsx'){
          const wsU = XLSX.utils.aoa_to_sheet(unmatchedAoa);
          const wbU = XLSX.utils.book_new();
          XLSX.utils.book_append_sheet(wbU,wsU,'未匹配');
          const outU = XLSX.write(wbU,{bookType:'xlsx',type:'array'});
          unmatchedBlob = new Blob([outU],{type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
        }else{
          unmatchedBlob = new Blob([toCSV(unmatchedAoa)],{type:'text/csv;charset=utf-8'});
        }
      }
      postMessage({
        cmd:'match-done',
        taskId,
        total,
        matched,
          unmatched,
        rate:matchRate,
        header:newHeader,
        previewRows:previewOut.slice(1),
        exportType,
        blob,
        unmatchedBlob,
        elapsed:Date.now()-startTime
      });
    }
    else if(cmd==='cancel'){
      // 由于算法是同步循环，真正取消需要在循环中检查标志。此简化版本提示无法中断已经在执行的密集块。
      // 这里预留标志位实现(可扩展分块+ async)
      postMessage({cmd:'cancel-ack',taskId});
    }
  }catch(err){
    postMessage({cmd:'error',taskId,message:err.message,stack:err.stack});
  }
};
`;
worker = new Worker(URL.createObjectURL(new Blob([code],{type:'application/javascript'})));
worker.onmessage = handleWorkerMessage;
}
createWorker();

/* ------------------ 工具函数 ------------------- */
function log(areaId,msg){
const box = document.getElementById(areaId);
if(!box) return;
if(box.classList.contains('hidden')) box.classList.remove('hidden');
const time = new Date().toLocaleTimeString();
box.textContent += '['+time+'] '+msg + '\\n';
box.scrollTop = box.scrollHeight;
}
function bytesToSize(bytes){
if(bytes<1024) return bytes+' B';
if(bytes<1024*1024) return (bytes/1024).toFixed(1)+' KB';
return (bytes/1024/1024).toFixed(2)+' MB';
}
function estMemory(rows,cols){
const perCell = 40; // 粗估字符串/对象开销
return (rows*cols*perCell/1024/1024).toFixed(1)+' MB (估算)';
}
function setHidden(id,flag){document.getElementById(id).classList.toggle('hidden',flag);}
function escapeHTML(str){
return (str==null?'':(''+str).replace(/[&<>"']/g,s=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[s])));
}

/* ------------------ 上传与预览 ------------------- */
document.getElementById('file1').addEventListener('change',e=>handleFile(1,e));
document.getElementById('file2').addEventListener('change',e=>handleFile(2,e));

function handleFile(idx,e){
const file = e.target.files[0];
if(!file) return;
fileBuffers[idx]=null; // reset
selectedSheet[idx]=null;
headers[idx]=[];
setUploadStatus(idx,'解析中...');
const isCSV = /\.csv$/i.test(file.name);
if(file.size > BIG_FILE_SIZE_WARN){
  const t = document.getElementById('bigFileTips');
  t.innerHTML = '⚠️ 文件 '+escapeHTML(file.name)+' 大小 '+bytesToSize(file.size)+'，建议：1) 转 CSV 显著加速 2) 确保只保留必要列 3) 拆分后逐个匹配。';
  t.classList.remove('hidden');
}
const fr = new FileReader();
fr.onload = ev=>{
  fileBuffers[idx] = ev.target.result;
  const taskId = ++currentTaskId;
  worker.postMessage({cmd:'preview',taskId,fileId:'f'+idx,buffer:fileBuffers[idx],isCSV,isCSVOriginal:isCSV,filename:file.name});
  log('uploadLog','开始解析文件('+idx+')：'+file.name);
};
fr.readAsArrayBuffer(file);
}
function setUploadStatus(idx,text){
const box = document.getElementById('u'+idx);
const info = document.getElementById('u'+idx+'-info');
info.textContent = text;
box.classList.add('active');
}

function handleWorkerMessage(e){
const d = e.data;
if(d.cmd==='error'){
  log('uploadLog','❌ 任务'+d.taskId+' 错误：'+d.message);
  alert('Worker 错误：'+d.message);
  return;
}
if(d.cmd==='preview-done'){
  log('uploadLog','文件预览完成 fileId='+d.fileId+' sheets='+d.sheetsMeta.length);
  const idx = d.fileId==='f1'?1:2;
  buildSheetList(idx,d.sheetsMeta);
}
if(d.cmd==='refreshPreview-done'){
  const idx = d.fileId==='f1'?1:2;
  applyPreview(idx,{
    name:d.sheetName,
    header:d.header,
    previewRows:d.previewRows,
    rawRows:d.rawRows,
    cleanRows:d.cleanRows
  });
  log('uploadLog','重新清洗完成 '+d.sheetName+' 行:'+d.cleanRows);
}
if(d.cmd==='match-progress'){
  const pct = d.percent;
  updateProgress(pct,d.progress,d.total,d.matched);
}
if(d.cmd==='match-done'){
  resultMeta = d;
  updateProgress(100,d.total,d.total,d.matched,true);
  showMatchStats(d);
  buildVirtualTable('resultPreview',[d.header,...d.previewRows]);
  setHidden('panel-result',false);
  log('resultLog','匹配完成 耗时 '+(d.elapsed/1000).toFixed(2)+'s 导出类型='+d.exportType);
  exportedBlobInfo = {
    blob:d.blob,
    unmatchedBlob:d.unmatchedBlob,
    exportType:d.exportType,
    filename: d.exportType==='xlsx' ? '表格匹配结果.xlsx' : '表格匹配结果.csv',
    unmatchedFilename: d.exportType==='xlsx' ? '未匹配行.xlsx' : '未匹配行.csv'
  };
  document.getElementById('exportHint').textContent = '导出类型：'+(d.exportType==='xlsx'?'Excel (行列量适中)':'CSV (数据量超大自动使用 CSV)')+
    ' ｜ 预览仅前 150 行';
  document.getElementById('btnDownload').disabled = false;
  document.getElementById('btnDownloadUnmatched').disabled = !d.unmatchedBlob;
  document.getElementById('btnCancelTask').classList.add('hidden');
}
if(d.cmd==='cancel-ack'){
  log('matchLog','收到取消响应（当前实现为同步匹配，可能无法立即中断）');
}
}

function buildSheetList(idx,meta){
const areaId = idx===1?'sheetArea1':'sheetArea2';
setHidden(areaId,false);
const list = document.getElementById(idx===1?'sheetList1':'sheetList2');
list.innerHTML='';
meta.forEach(m=>{
  const div = document.createElement('div');
  div.className='sheet-item';
  div.innerHTML = '<strong>'+escapeHTML(m.name)+'</strong>'+
    (m.error?('<div class="danger-box">解析失败:'+escapeHTML(m.error)+'</div>'):
    ('<div class="meta">'+
      (m.header?.length?('列:'+m.header.length):'')+
      (m.cleanRows!=null?(' 行:'+m.cleanRows):'')+
    '</div>'));
  if(!m.error){
    div.addEventListener('click',()=>applyPreview(idx,m,div));
  }else{
    div.style.opacity=.6;
  }
  list.appendChild(div);
});
}

function applyPreview(idx,meta,divEl){
// 选中样式
const list = document.getElementById(idx===1?'sheetList1':'sheetList2');
list.querySelectorAll('.sheet-item').forEach(el=>el.classList.remove('active'));
if(divEl) divEl.classList.add('active');
selectedSheet[idx]=meta.name;
previewMeta[idx]=meta;
headers[idx]=meta.header||[];
// 渲染虚拟表
buildVirtualTable(idx===1?'tablePreview1':'tablePreview2',[meta.header,...meta.previewRows]);
document.getElementById(idx===1?'previewWrap1':'previewWrap2').classList.remove('hidden');
document.getElementById(idx===1?'pvMeta1':'pvMeta2').textContent = '列:'+meta.header.length+' 预览行:'+meta.previewRows.length+' 总(清洗后)行:'+meta.cleanRows+' 估算内存:'+estMemory(meta.cleanRows,meta.header.length);
log('uploadLog','选择工作表 '+meta.name+' (文件'+idx+')');
maybeEnableConfig();
}

function maybeEnableConfig(){
if(selectedSheet[1] && selectedSheet[2]){
  // 填充字段下拉
  fillSelectOptions('key1',headers[1]);
  fillSelectOptions('key2',headers[2]);
  buildFieldGrid();
  document.getElementById('selSheet1').textContent = selectedSheet[1];
  document.getElementById('selSheet2').textContent = selectedSheet[2];
  setHidden('panel-config',false);
  document.getElementById('panel-config').scrollIntoView({behavior:'smooth'});
}
}

function fillSelectOptions(id,arr){
const sel = document.getElementById(id);
sel.innerHTML='';
arr.forEach((h,i)=>{
  const op = document.createElement('option');
  op.value=i; op.textContent=h;
  sel.appendChild(op);
});
}

function buildFieldGrid(){
const grid = document.getElementById('fieldGrid');
grid.innerHTML='';
headers[2].forEach((h,i)=>{
  const labelId = 'fld_'+i;
  const wrap = document.createElement('div');
  wrap.className='field-item';
  wrap.innerHTML=`<input type="checkbox" id="${labelId}" value="${i}" checked><label for="${labelId}">${escapeHTML(h)}</label>`;
  grid.appendChild(wrap);
});
}

/* ------------------ 虚拟表格渲染 ------------------- */
function buildVirtualTable(containerIdOrElem,data){
const container = typeof containerIdOrElem==='string'?document.getElementById(containerIdOrElem):containerIdOrElem;
if(!data || !data.length){container.innerHTML='<div class="small" style="padding:8px">无数据</div>';return;}
const header = data[0];
const rows = data.slice(1);
container.innerHTML='';
// 框架
const table = document.createElement('table');
table.className='virtual-table';
const thead = document.createElement('thead');
const trh = document.createElement('tr');
header.forEach(h=>{
  const th = document.createElement('th'); th.textContent = h; trh.appendChild(th);
});
thead.appendChild(trh);
const tbody = document.createElement('tbody');
table.appendChild(thead);
table.appendChild(tbody);
container.appendChild(table);
container.appendChild(Object.assign(document.createElement('div'),{className:'shadow-fade shadow-top'}));
container.appendChild(Object.assign(document.createElement('div'),{className:'shadow-fade shadow-bottom'}));
// 虚拟滚动
const total = rows.length;
const viewportHeight = container.clientHeight;
const visibleCount = Math.ceil(viewportHeight / VIRTUAL_ROW_HEIGHT) + 8;
let startIndex=0;
const spacerTop = document.createElement('tr');
const spacerBottom = document.createElement('tr');
function render(){
  tbody.innerHTML='';
  const end = Math.min(total,startIndex+visibleCount);
  // top spacer
  const topHeight = startIndex * VIRTUAL_ROW_HEIGHT;
  spacerTop.innerHTML = `<td colspan="${header.length}" style="height:${topHeight}px;padding:0;border:none;background:transparent;"></td>`;
  tbody.appendChild(spacerTop);
  for(let i=startIndex;i<end;i++){
    const tr = document.createElement('tr');
    const row = rows[i];
    for(let c=0;c<header.length;c++){
      const td = document.createElement('td');
      td.textContent = row?.[c] ?? '';
      tr.appendChild(td);
    }
    tbody.appendChild(tr);
  }
  const bottomHeight = (total - end) * VIRTUAL_ROW_HEIGHT;
  spacerBottom.innerHTML = `<td colspan="${header.length}" style="height:${bottomHeight}px;padding:0;border:none;background:transparent;"></td>`;
  tbody.appendChild(spacerBottom);
}
function onScroll(){
  const scrollTop = container.scrollTop;
  const newStart = Math.floor(scrollTop / VIRTUAL_ROW_HEIGHT);
  if(Math.abs(newStart-startIndex) > 3){
    startIndex = Math.max(0,Math.min(total,newStart));
    render();
  }
}
container.addEventListener('scroll',onScroll);
render();
}

/* ------------------ 配置操作 ------------------- */
document.getElementById('btnAll').addEventListener('click',()=>{
document.querySelectorAll('#fieldGrid input[type=checkbox]').forEach(cb=>cb.checked=true);
});
document.getElementById('btnNone').addEventListener('click',()=>{
document.querySelectorAll('#fieldGrid input[type=checkbox]').forEach(cb=>cb.checked=false);
});
document.getElementById('btnInvert').addEventListener('click',()=>{
document.querySelectorAll('#fieldGrid input[type=checkbox]').forEach(cb=>cb.checked=!cb.checked);
});
document.getElementById('btnBack').addEventListener('click',()=>{
document.getElementById('panel-upload').scrollIntoView({behavior:'smooth'});
});

document.querySelectorAll('[data-preview-refresh]').forEach(btn=>{
btn.addEventListener('click',()=>{
  const idx = parseInt(btn.getAttribute('data-preview-refresh'),10);
  if(!selectedSheet[idx]) return;
  const taskId = ++currentTaskId;
  worker.postMessage({cmd:'refreshPreviewSheet',taskId,fileId:'f'+idx,sheetName:selectedSheet[idx]});
  log('uploadLog','重新清洗请求 file '+idx+' sheet '+selectedSheet[idx]);
});
});

/* ------------------ 开始匹配 ------------------- */
document.getElementById('btnStartMatch').addEventListener('click',()=>{
const k1 = parseInt(document.getElementById('key1').value,10);
const k2 = parseInt(document.getElementById('key2').value,10);
const mode = document.getElementById('matchMode').value;
const unmatchedFill = document.getElementById('unmatchedFill').value;
const fields = [];
document.querySelectorAll('#fieldGrid input[type=checkbox]:checked').forEach(cb=>fields.push(parseInt(cb.value,10)));
if(fields.length===0){alert('请至少选择一个追加字段');return;}
if(!selectedSheet[1] || !selectedSheet[2]){alert('请先选择两个工作表');return;}
document.getElementById('btnStartMatch').disabled = true;
document.getElementById('btnCancelTask').classList.remove('hidden');
log('matchLog','开始匹配...');
setHidden('matchLog',false);
setHidden('panel-result',false);
buildVirtualTable('resultPreview',[['处理中...']]);
updateProgress(0,0,0,0);
const taskId = ++currentTaskId;
worker.postMessage({
  cmd:'startMatch',
  taskId,
  file1:'f1',
  file2:'f2',
  sheet1:selectedSheet[1],
  sheet2:selectedSheet[2],
  key1:k1,
  key2:k2,
  mode,
  fields,
  unmatchedFill
});
});

document.getElementById('btnCancelTask').addEventListener('click',()=>{
const taskId = ++currentTaskId;
worker.postMessage({cmd:'cancel',taskId});
});

function updateProgress(pct,done,total,matched,finished){
document.getElementById('progressFill').style.width = pct+'%';
document.getElementById('progressText').textContent = pct+'%';
document.getElementById('progressDetail').textContent = finished
  ? '匹配完成 行:'+total+' 成功:'+matched
  : '处理中... 已处理 '+done+'/'+total+' 行 匹配:'+matched;
}

function showMatchStats(d){
document.getElementById('statTotal').textContent = d.total;
document.getElementById('statMatched').textContent = d.matched;
document.getElementById('statUnmatched').textContent = d.unmatched;
document.getElementById('statRate').textContent = (d.rate*100).toFixed(2)+'%';
}

/* ------------------ 下载导出 ------------------- */
document.getElementById('btnDownload').addEventListener('click',()=>{
if(!exportedBlobInfo){alert('尚无结果');return;}
saveBlob(exportedBlobInfo.blob,exportedBlobInfo.filename);
});
document.getElementById('btnDownloadUnmatched').addEventListener('click',()=>{
if(!exportedBlobInfo || !exportedBlobInfo.unmatchedBlob){
  alert('没有未匹配行或未生成');return;
}
saveBlob(exportedBlobInfo.unmatchedBlob,exportedBlobInfo.unmatchedFilename);
});
function saveBlob(blob,filename){
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href=url; a.download=filename;
document.body.appendChild(a);
a.click();
setTimeout(()=>{URL.revokeObjectURL(url);a.remove();},500);
}

/* ------------------ 重置 ------------------- */
document.getElementById('btnResetAll').addEventListener('click',resetAll);
function resetAll(){
fileBuffers={1:null,2:null};
selectedSheet={1:null,2:null};
previewMeta={1:null,2:null};
headers={1:[],2:[]};
exportedBlobInfo=null;
document.getElementById('file1').value='';
document.getElementById('file2').value='';
['sheetArea1','sheetArea2','previewWrap1','previewWrap2','panel-config','panel-result','bigFileTips'].forEach(id=>setHidden(id,true));
document.getElementById('uploadLog').textContent='';
document.getElementById('matchLog').textContent='';
document.getElementById('resultLog').textContent='';
document.getElementById('u1-info').textContent='点击选择 (.xlsx/.xls/.csv)';
document.getElementById('u2-info').textContent='点击选择 (.xlsx/.xls/.csv)';
document.getElementById('u1').classList.remove('active');
document.getElementById('u2').classList.remove('active');
log('uploadLog','已重置。');
window.scrollTo({top:0,behavior:'smooth'});
}

/* ------------------ 其他 ------------------- */
window.addEventListener('error',e=>{
log('uploadLog','页面错误: '+e.message);
});
</script>
</body>
</html>